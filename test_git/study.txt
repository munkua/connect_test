https://velog.io/@kimmachinegun/tags/golang golang 유용글 sync, pool
https://godoc.org go 문서
https://www.udemy.com/course/learn-go-the-complete-bootcamp-course-golang/?referralCode=5CE6EB34E2B1EF4A7D37
https://medium.com/@joongwon/jvm-garbage-collection-algorithms-3869b7b0aa6f gc 알고리즘
https://github.com/KennethanCeyer/learn-golang-kr/wiki go언어 깃허브
https://okky.kr/articles/community 
http://www.yes24.com/Product/Goods/44305533 코딩인터뷰 정복
https://jacking75.github.io/go_PerformanceTuning/ golang 성능튜닝
https://goodgid.github.io/What-is-Thread/ 쓰레드란?


https://velog.io/@kimmachinegun/tags/golang golang 유용글 sync, pool
https://godoc.org go 문서
https://www.udemy.com/course/learn-go-the-complete-bootcamp-course-golang/?referralCode=5CE6EB34E2B1EF4A7D37
https://medium.com/@joongwon/jvm-garbage-collection-algorithms-3869b7b0aa6f gc 알고리즘
https://github.com/KennethanCeyer/learn-golang-kr/wiki go언어 깃허브
https://okky.kr/articles/community 
http://www.yes24.com/Product/Goods/44305533 코딩인터뷰 정복
https://www.a-ha.io/questions/categories/3 질문자주올라오는곳
http://wiki.hash.kr/index.php/합의_알고리즘

제어문자
%T 타입
%x 배열 등 모든원소 출력
%t 참, 거짓
%d 정수
%.nf n자리까지 부동소수점
%b 비트

포트폴리오 작성하기 위해서 go로 좋은코드, 메모리 관리가 잘 되는 코드를 작성하고
백준 알고리즘에서 문제를 풀어 github에 업로드해보자

go는 다른언어처럼 여러개의 기본적인 구조가 모여 큰 프로그램을 빌드하고 변수는 값을 저장한다. 
이번챕터에선 기본구조 원소 go 언어 알아봄

go 함수, 변수, 상수, 타입, 문, 패키지의 이름은 간단한 룰을 따른다.
시작은 문자, 언더바로 시작하고 그 뒤에 아무숫자나 문자가 따른다.

go에는 25가지 키워드가 존재한다. (사진)
이 키워드는 변수나 상수의 이름으로 사용할 수 없다.
또한 int 나 true처럼 빌트인타입, 함수 등이 존재한다. (사진)
해당 이름들은 예약되지 않았으므로 선언시 사용이 가능하다.
만약 개체가 함수에안에서 선언되었으면 그 개체는 함수에 지역적이다.
만약 함수 밖에서 선언되었다면 해당 패키지를 가지 모든파일에 종속적이다.
이름의 첫번째 문자는 패키지의 경계에서 가시성을 결졍한다.	
만약 이름이 대문자로 시작하는 경우 이것은 외부적이다.
이것은 가시적이고 접근가능하단것을 뜻한다. 우리의 패키지의 밖에서 그리고 다른 프로그램의 파트에서도 참조 가능하다.
ex) Printf는 fmt패키지에속한다.
또한 외부에서 참조되는 함수는 대문자로 시작한다. ex)Printf는 fmt패키지 내부에 정의됨.
또한 줄임말보다는 의미가 명확하게 변수를 작명하는게 좋음
ex) for루프 시 i보다는 theLoopIndex처럼..

언어 스타일적으로 go언어는 2음절 이상의 단어에 낙타체를 사용한다.
음절사이에 언더바 보다는 대문자로 구분하는것을 선호한단뜻이다.
그러모르 스탠다드 라이브러리는 QuoteRuneToASCII나 parseRequestLine 같이 작명된 함수를 가진다.
여기서 HTML이나 ASCII는 항상 대문자로 사용해야하는 단어이다.
ex) HTMLEscape, escapeHTML

- 선언
선언은 프로그램 엔티티를 명명하고 그 속성의 일부 또는 전체를 명시한다.
선언에는 네가지 주 선언이 존재한다.

go에는 25가지 키워드가 존재한다. (사진)
이 키워드는 변수나 상수의 이름으로 사용할 수 없다.
또한 int 나 true처럼 빌트인타입, 함수 등이 존재한다. (사진)
해당 이름들은 예약되지 않았으므로 선언시 사용이 가능하다.
또한 외부에서 참조되는 함수는 대문자로 시작한다. ex)Printf는 fmt패키지 내부에 정의됨.
또한 줄임말보다는 의미가 명확하게 변수를 작명하는게 좋음
ex) for루프 시 i보다는 theLoopIndex처럼..

언어 스타일적으로 go언어는 2음절 이상의 단어에 낙타체를 사용한다.
음절사이에 언더바 보다는 대문자로 구분하는것을 선호한단뜻이다.
그러모르 스탠다드 라이브러리는 QuoteRuneToASCII나 parseRequestLine 같이 작명된 함수를 가진다.
여기서 HTML이나 ASCII는 항상 대문자로 사용해야하는 단어이다.
ex) HTMLEscape, escapeHTML

- 선언
선언은 프로그램 엔티티를 명명하고 그 속성의 일부 또는 전체를 명시한다.
선언에는 네가지 주 선언이 존재한다.
var, const, type, func
우린 여기서 변수 선언인 var를 살펴볼것이다.
go 프로그램은 .go 확장자로 하나 또는 그 이상의 파일로 저장된다.
각 파일은 파일의 일부라는것을 나타내는 패키지 선언으로 시작한다.
패키지 선언은 어떤 import 선언에 따른다. 그리고 타입, 변수, 상수, 함수 패키지레벨 순서의 선언에 따른다.
예를들어 해당 프로그램은 상수, 함수, 2개의 변수를 선언한다.
(예시코드)
상수 bolingF는 패키지 레벨 선언이다.
반면 c,f 변수는 main 함수의 지역변수이다.
패키지레벨 개체의 이름은 소스코드 뿐만 아니라 해당 패키지를 선언한 모든 go 파일의 범위에서 볼 수 있다.
대조적으로 지역내에서 선언된 c,f 변수의 범위는 main함수내이다.
함수선언은 이름, 매개변수 리스트(함수 호출자에 의해 정의된 변수들), 추가적인 결과의 리스트, 함수가 어떤 동작을 할지 정의한 문(statement)를 가진 함수몸체로 선언된다.
결과 리스트는 함수가 아무것도 리턴하지 않을 시 배제된다.
함수는 첫 문(statement)부터 리턴문 또는 함수의 마지막 부분을 만날때 까지 실행한다.
실행이 끝난 뒤 제어권, 결과는 함수 호출자에게로 넘어간다.
(예시)함수 fToC는 화씨 온도를 섭씨 온도로 변환하는 기능을 하는 캡슐화된 함수이다.
여기서 함수는 2번 호출되고 2개의 다른 상수 지역변수가 사용된다.

- 변수
변수 선언 var는 특정 타입을 가진 새 변수를 만든다. 이름을 붙이고 초기값을 설정한다.
기본적으로 해당 형식을 가진다.
var name type = expression

타입 또는 = expression 파트는 아마 빠뜨렸ㅆ을것이다. 하지만 둘 다는 안된다.
타입이 배제되면 expression에 의해서 결졍된다.
expression이 배제되면 초기값은 각 타입의 zero value이다.
bool의 경우 false, 숫자의 경우 0, string의 경우 "", 인터페이스나 참조(slice, 포인터, map 채널, 함수)의 경우 nil이다.
총계하는 타입 ex)array, 구조체 의 경우 zero value는 각 원소, 필드의 zero value이다.
zero value메커니즘은 변수가 항상 각 타입의 잘 정의된 값을 가지도록 만든다.
go언어에서는 초기화되지않은 변수란 없다.
이것은 코드를 단순화시키고 추가적인 작업 없이 합리적인 행동을 보장한다.
예시코드()
빈 string을 출력하는것이 에러를 유발하거나 예상치못한 행동을 하는것이 더 좋다.
또한 하나의 선언에서 여러개의 변수를 초기화 할 수 있다.
(예시코드)
bool:                    %t
int, int8 etc.:          %d
uint, uint8 etc.:        %d, %#x if printed with %#v
float32, complex64, etc: %g
string:                  %s
chan:                    %p
pointer:                 %p

2.3.1 짧은 변수 선언 ( 변수 선언하는 또다른 방법 )
short variable declaration 연산자 := 는 golang에서 변수에 적절한 값, 이름을 지정하기 위해 사용한다.
이 연산자는 간결성과 유연성을 지니므로 주로 함수 내부의 로컬 변수를 선언, 초기화하고 변수의 범위를 좁히는것이 주 목적으로 사용된다.
간결성을 지니는 이유는 var처럼 타입을 명시적으로 나타내지않고, 변수에 값을 나중에 할당하고 초기 값이 중요하지 않은경우 사용한다. 즉, 변수선언을 우선하고 값에의해 타입이 결정된 후 할당된다.
var 변수 선언과 다르게 := 변수의 타입은 표현에 의해서 결졍된다.
주의점은 var 키워드는 함수 내부, 외부에서 모두 사용가능하지만 := 연산자 선언은 함수 내부같은 지역변수를 선언할 때만 사용할 수있단것이다.
또한 여러개의 변수 선언과 같은 가독성을 높이기 위할때 사용하는것이 좋다.
짧은변수선언은 필수적으로 선언의 기능을 하진않는다.
만약 변수 중 하나가 관찰 가능한 범위 내에서 이미 선언되었다면 짧은변수 선언은 할당처럼 동작한다.
그리고 짧은 변수 선언은 재정의 시 오류 발생.
적어도 하나 이상의 새로운 선언이 필요하다
es, err := 1, 3	es, err := 1, 3
os, err := 1, 4	es, err := 1, 3 // error

var, short 다른점
1. var는 go언어에서 제공하는 문법적 키워드이다. / :=는 short declaration 'operator' 즉 연산자이다.
2. 함수 내,외 적으로 변수를 선언 ,초기화시 사용한다, / 오직 함수 내부에서만 선언이 가능하다.
3. 사용할 시 변수는 보통 패키지레벨 또는 글로벌 레벨 범위를 가진다. 또한 지역범위로도 사용이가능하다
/ 지역단위로의 범위만 가질 수 있고, 함수 내부에서만 선언된다.
4. 선언과 초기화를 따로할 수 있다. / 선언과 초기화가 동시에 이뤄진다.
5. 타입을 추가적으로 추가해줘야한다. / 타입을 입력할 필요가 없다.

2.3.2 포인터

변수란 값을 포함하는 저장소의 조각이다.
선언을 통해 생성된 변수는 이름에 의해 식별된다. ex) var x 등..
하지만 많은 변수는 표현에 의해 식별된다.  x[i]나 x.f등..
이러한 모든 표현은 변수의 값을 읽는다. 그들이 좌측 할당에서 나타날때를 제외하고.
이러한 경우는 새로운 값을 변수에 할당하는것이다.

포인터의 값은 변수의 주소이다.
그러므로 포인터란 값이 저장된 위치란 뜻이다.
포인터가 있다면 우리는 변수의 값을 즉시 읽거나 수정이 가능하다.

var x int라고 선언된 변수가 있다면 &x("address of x")라는 표현은 정수변수에 대한 포인터이다.
즉, *int 타입의 값이란 뜻이고 pointer to int 이므로 &x는 point to x 이 된다.
만약 x 가 p에의해 지목되면
p points to x이고 p는 x의 주소를 가진다 라고도 해석이 가능하다.
또한 배열같이 어떠한 타입을 묶어놓은 타입 또한 각 원소가 주소를 지닌다.
또한 포인터의 zero value는 nil이다.
또한 포인터끼리 비교할 시 같은 변수를 지목하면 같은 포인터이다.
이것은 함수에게 완벽히 안전하다 지역변수의 주소를 리턴할 때
예를들어 밑 코드에서  특정 함수호출 f에 의해서 v가 만들어지는데 v는 호출이 종료되어도 남아있다.
* 나중에 더..포인터는 flag 패키지의 키 포인트다.
커맨드 라인 인자에 특정 값을 프로그램을 통해 변수에 뿌린다.
실현을위해 

2.3.3 new function

변수 생성하는 방법임. built-in 함수인 new 함수 사용하는것
new(t)의 표현은 이름이 정해지지않은 타입 t 의 변수를 만든다. t의 zero value로 초기화된다.
그리고 주소를 리턴한다. 따라서 값의 타입은 *t이다.
"주로 구조체와 함께 사용할 때 유용하다"
func new(Type) *type
ex) p := new(int) p는 *int형 포인터변수이다.
new 함수를 이용하거나 var를 이용하거나 차이점이 없지만, new함수를 이용한 경우 명명하지 않아도 된다는 점이 있다. 왜 이게 편하냐면
예를들어 자료구조에서의 연결리스트를 만들 때 처음에 초기화를 할때 getnode()함수를 사용할 수 있는데 이 때 간편히 사용할 수 있다.

func getNode *node {
	return new(node)
}

또한 new 함수로 만들어진 포인터는 고유한 주소를 가진다.
p := new(int)
q := new(int)
fmt.Println(p == q) // false
룰의 하나의 예외가 있는데
유형이 정보를 전달하지 않고 따라서 크기가 0인 두 변수
struct {}나 [0]int 같은 경우 실행할 경우에 따르고 같은 주소를 가진다.

new함수는 상대적으로 드문드문 사용된다 왜냐하면 구조체 타입의 흔한 비작명 변수는 struct 리터럴 syntax가 더 유용하기때문

new 함수는 keyword가 아니므로 이름 재정의가능 
func delta(old, new int) int {return new - old}

2.3.4 변수의 생애주기
변수의 생애주기는 시간사이의 간격이다 프로그램이 실행되는 동안의
패키지레벨의 변수의 생애주기는 프로그램 전체의 실행시간동안이다.
대조적으로 지역변수는 동적인 생애주기를가진다.
새로운 인스턴스가 만들어지고 선언문이 실행될때, 변수는 살아있다 unreachable까지, 그시점 저장소는 재사용된다.
함수 매개변수와 결과 또한 지역변수와 같다. 함수가 호출될때부터 종료될때까지이다.

가비지콜렉터는 어케알고 수집하노?
기본 아이디어는 현재 활성화된 패키지레벨 변수 그리고 함수에서 활성화된 모든 지역변수는
잠재적으로 해당 변수에 대한 경로의 시작 또는 루트일 수 있다.
따라오는 포인터, 다른 종류의 참조는 궁극적으로 변수에게 이끈다.
만약 그러한 경로가 없다면 변수는 unreachable이 되고 이것은 더이상  남은 연산에 영향을 끼치지 못한다.

왜냐면 변수의 생애주기는 도달가능여부에 달려있기 때문이다.
지역변수는 생애주기가 연장된다 근처의 loop의 단독 반복에서
이것은 존재를 지속시키고 인접 함수가 닫힌후에도 지속된다.
컴파일러는 아마 고르려고 할것이다.. 할당한 지역변수 힙위의 또는 스택 하지만 아마도 놀랍게도
이 선택은 var 또는 new 에의해 선언될 때 결정되지않는다.
var global *int
func f() {			func g() {
	var x int			y := new(int)
	x = 1				*y = 1
	global = &x	}	
}
여기서 x는 힙에 할당되어야한다. 왜냐면 global변수에의해 f가 리턴된이후에도 관찰가능하기때문
우린 이것을 x가 excape from f 라고한다.
대조적으로 g는 리턴되면 변수 *y는 관찰되지못하고 재활용된다.
*y가 g에서 탈출하지 못했으므로 컴파일러는 *y를 스택에 할당하는것이 안전하다. new로 할당되었음에도 불구하고말이다.

어떠한 경우에도 escape의 개념은 코드작성 시 신경쓸 문제가 아니다.
그래도 항상 프로그램의 최적화 퍼포먼스를 위해서 기억해두는것이 좋다.
escape 작업시 추가적인 메모리 할당이 필요하기 때문이다.

쓰레기 수집은 좋은 프로그램을 작성하기 위해 엄청나게 도움이 된다.
하지만 당신이 메모리를 신경쓰지 않게 만든는것은 아니다.
당신이 명시적으로 메모리를 free해주지않아도 되지만 효율적인 프로그램을 위해 변수의 생애주기를 항상 염두에둬야한다.
예를들어 장수하는 물체, 특히 글로벌한 '변수' 안에 단명하는 물체에 대한 불필요한 포인터를 보관하는 것은 쓰레기 수집가가 단명된 객체를 수거하는것을 막을것이다.

2.4 할당
변수에 의해 잡힌 값은 할당문에 의해 갱신된다.
간단한 형태를 가진다 변수 = 표현
variable = expression

2.4.1 tuple 할당
할당의 다른형태, tuple 할당 허용한다. 다양한 변수를 한번에 할당하는것을
모든 오른쪽 표현은 평가된다 변수가 갱신되기 전에
이 형태를 가장 효율적으로 만드는것은 양 쪽에 변수가 할당되었을때이다. 예를들어 두 변수를 바꾸는 함수를 작성하려면?
x, y = y, x
튜플 할당 시 = 연산자 기준으로 오른쪽 표현부터 평가된다.
그 후 좌항에서 오른쪽 표현부터 순서에 맞게 할당된다.
예를들어 x, y = y, x+y 라는 구문이 있다고한다면
y에 x+y가 할당되고 x에 y의 값이 할당된다.

또한 튜플 할당은 blank identifier 와 함께 쓸 수 있다.
blank identifier는 선언되었지만 사용되지않아도 되는 변수를 말한다.
주로 2개이상의 리턴타입을 가지는 함수에서 값을 리턴받을 때 어떤 값을 사용하기 원치않을 때 사용한다.
공백 식별자는 값으로 사용할 수 없고 주소도 가지지 않는다.
또한 공백 식별자는 한 범위 내에서 여러번 선언할 수 있다.


2.5 타입선언
변수나 표현의 유형은 그것이 취할 수 있는 값의 특성을 정의한다.
그들의 사이즈나 내부적으로 어떻기 표현되는지, 그들이 사용할 수 있는 고유한 연산자, 연관된 메소드에 달렸다.
어떤 프로그램에서나 같은 묘사를 공유하지만 전혀 다른 컨셉을 지닌 변수가 있다.
예를들어 int는 loop의 index나 파일설명자나 달력의 달을 묘사할 수 있고
float64는 속도, m/s, 온도 등을 묘사할 수 있고
string은 비밀번호, 이름, 색깔 등을 묘사할 수 있다.

타입 선언은 go언어에 정의되어있는 타입과 이름만 다르고 근본적으로 같은 타입을 정의하는것이다.
작명된 타입은 다른 타입으로 제공되므로 go언어에 정의된 타입과 비교할 수 없다
.타입 선언은 종종 패키지레벨 에서 보인다.
만약 작명 시 이름의 첫글자가 대문자라면 패키지 밖에서도 접근이 가능하다.
import "fmt"
type Celsius float64
type Fahrenheit float64
const (
AbsoluteZeroC Celsius = -273.15
FreezingC Celsius = 0
BoilingC Celsius = 100
)
func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
패키지는 두개의 타입을 정의한다
두 타입모두 float64이지만 같은 타입은 아니다. 따라서 둘은 산술연산자로 비교하거나 합칠 수 없다
타입을 구분하는것은 에러를 막아주고 무심코 다른 스케일을 합치는것을 막는다.
예를들어 명시적인 타입변환 // 함수아님 ->Celsius(t)나 Fahrenheit(t)같은 경우에말이다.
이 경우 어떠한 경우에도 값이나 표현을 변경하지 않는다.
하지만 그들은 명시적인 의미를 변화시킨다. 즉, float64와 값이나 표현은 같지만 다른 표현인 Celcius로 바꿀 수 있다는 의미이다.
반면 CToF나 FToC는 두 스케일 간 변환을 한다.
두 함수는 다른 값을 리턴한다.

모든타입 t에 대해 비교가능한 연산 t(x)가 존재한다.
t(x)는 값x를 t타입으로 변환하는 연산자이다.
변환은 두 타입이 근본적으로 같은 타입일 경우 가능하다.
또는 두 타입모두 같은 근본타입을 가진 변수를 포인트하는 작명되지 않은 포인터인경우 가능하다.
이러한 변환은 타입을 변경하지만 표현된값을 바꾸진않는다.
x가 t에 할당가능할 변환은 허용되지만 대개 쓸모없는것들이다.
예를들어 t,x 모두 int16 타입인데 굳이 변환을 할 필요는 없다.

변환은 숫자(numeric type)사이에 가능하다.
그리고 스트링과 slice타입 사이에도 가능하ㅏㄷ.
이러한 변환은 값의 표현을 바꿀수 있다.
예를들어 부동소수점에서 정수로의 변환은 소수점부분을 버리고
스트링에서 []byte로의 변환은 스트링의 데이터 복사본을 슬라이스에 할당한다.
어떤경우던 변환은 런타임시 절대 실패치않는다.

작명된 타입의 기본 유형은 구 구조와 표현, 그리고 그것이 지원하는 내적 운영의 집합을 결정하는데 이는 기본 유형을 직접 사용한것과 같다.
예를들어 float64로 연산을하거나 Celcius 타입으로 연산을 하나 동일한 연산작업을 수행한다는 것이다.
ex) 위에서 Celcius 타입으로 설정된 
FreezingC, BoilingC 두 타입은 같기때문에 산술연산

named type은 표기법의 편리성때문에 사용된다.
이표기법은 복잡한 타입을 작성하는것을 피하게한다.
float64따위로 작은 타입과 동일하게 예시를 들어서 왜사용하는지 이해가힘들 수 있지만.
다른 복잡한 타입, 기계의 동작상태같은 구조체같은.. 그러한 타입이 사용될 시 유용케 사용할 
수 있다.

또한 타입의 값에 새로운 행동을 정의할 수 있다.
이러한 행동들은 표현된다. 함수의 무리에 의해 타입과 관련된,
타입 메소드라고 불리는(chap.6)


2.6 패키지와 파일
go 안의 패키지는 다른 언어의 라이브러리와 동일한 목적을 가진다.
모듈화, 캡슐화, 분리 컴파일, 재사용을 돕는다,
패키지를 위한 소스코드는 하나 이상의 go파일에 저장되어있다.
대개 import path한 한 디렉토리에 있다.

각 패키지는 분리된 네임스페이스에서 제공된다. 이것을위한 선언에
~파일에 저장되고
사용하려면 package 패키지이름으로 저장
사용시 import 해주고 패키지이름.사용원하는 타입이름 등으로 사용하자.

2.6.1 imports
go에선 모든 패키지가 import path라고 불리는 고유한 스트링으로 구별된다.
이러한 스트링들은 import선언에서 나타난다.
ex) "gop1.io/ch2/tempconv" 같은..
언어는 이 스트링이 어디서왔는지, 무엇을 의미하는지 정의하지는않는다.
그것을 해석하는 툴에 달려있는것이다.
go tool(chap.10)사용 시 import path는 나타낸다.
디렉토리가 하나이상의 go소스파일을 포함한다는것을 패키지파일로 같이 만들어진,
https://thenewstack.io/understanding-golang-packages/


2.7 scope범위

선언은 연관짓는다. 이름ㅇ,ㄹ 프로그램 개체와 함께 함수나 변수처럼.
선언의 범위는 선언된 이름을 사용하는 것이 해당 선언을 가리키는 소스 코드의 부분이다.
범위를 생애주기와 혼동하면 안된다.
선언의 범위는 프로그램 텍스트의 지역이다.
이것은 컴파일타임 우선이다.
변수의 생애주기는 시간의 범위이다. 실행되는동안의,
만약 변수가 참조가능할때 다른 프로그램의 부분에서, 이것은 런타임 우선이다.
구문적인 블록은 문의 순서이다. 중괄호로 닫힌, 함수나 루프의 몸체와 같이.
구문블록안에 선언된 이름은 블록밖에선볼수없다.
블록은 그 선언문을 동봉하고 그 범위를 결정한다.
우리는 생성한다. 블록


go 특징
1. 정적타입, 강타입
정적 타이핑은 프로그램 실행 전 옳은가를 체크함
이작업은 주로 언어의 컴파일러가 수행한다. 자바..

동적 타이핑은
프로그램 실행중에만 타입을 알 수 있음. 파이썬..
def erroneous():
    s = 'cat' - 1

print('hi!')
해당코드 오류 x 하지만 erroneous 호출 시 오류발생

2. 컴파일언어
컴파일 = 소스코드에서 목적코드로옮기는 작업
과정
1) 소스파일을 바이너리파일로 번역
2) 실행 후 cpu에서 ram으로 로드
3) 결과출력
c++, java, go 등..

cpu가 알아들을 수 있는 기계어로 번역하는것임. 바이너리파일이라고도불림

인터프리터는 소스코드 가 컴파일러아닌 인터프리터에게 직접 번역, 실행동시에함
실행파일 존재하지않음, os에서 ram에 로드되어 cpu에서 실행
소스코드 한줄한줄읽으며 실행
jsp, 파이썬, sql등..

컴파일장점 : 컴파일 완료한 실행파일 존재하므로 인터프리터로 실행하는것보다 빠르게 동작
인터프리터 장점 : 컴파일x 별도의 컴파일시간 x
큰 소스코드에도 컴파일시간들지않아 바로실행가능

강타입은 타입체크의 강도에 따라 구분함
약타입은 int, float 더할시 암묵적형변환 허용치만
go언어는 int, float더할 시 컴파일 에러가 발생한다.

3. 가비지콜렉션
정의 : 사용되지 않는 메모리 공간을 free해주는것
즉, 범위 밖의 객체나 더이상 참조불가능한 객체의 메모리공간을 free하여 소비가능케만드는작업
이 작업은 프로그램 실행되는 동안 동시에 수행
바둑 가비지 수집기의 주요 관심사는 대기 시간이 짧다는 것인데, 이는 기본적으로 실시간 작업을 하기 위해 가동을 중단하는데도 금방 작업을 시작하기때문이다.
그럼 어떻게 이런 짧은 대기시간을가지는가?

한편, 프로그램이 하는 일은 항상 포인터를 사용하여 새로운 개체를 만들고 기존 개체를 조작하는 것이다.
이 프로세스는 이러한 개체를 가리키는 포인터가 없기 때문에 더 이상 액세스할 수 없는 개체를 생성하게 될 수 있다.
이 물건들은 쓰레기가 되고 쓰레기 수거업자가 그것들을 청소하고 그들의 기억 공간을 자유롭게 할 때까지 기다린다.
그 후 자유로워진 기억 공간은 다시 사용할 준비가 되어 있다.

- concurrent 마크앤스윕 알고리즘 사용
우선 각 Algorithm을 살펴보기에 앞서 어떤 Object를 Garbage로 볼 것이냐에 대한 이해가 글을 읽는 데 도움이 될 것이다. Garbage Collector는 객체를 Reachable과 Unreachable의 상태로 구분한다. 구분하는 방법은 Root set 과의 관계로 판단한다. Root Set으로부터 어떤 식으로든 Reference 관계가 있다면 Reachable Object라고 판단하고 Root Set으로부터 참조하는 Reference 관계가 없다면 Unreachable Object라고 판단한다. Root Set을 간단하게 설명하면 객체들 간에 참조 사슬의 시작점이라고 보면 된다.

cms gc 설명
mark단계에서 참조되지않는 자료 마크
councurrent mark 단계에서 한번더 확인
sweep 단계에서 가비지콜렉션 수행

- 초기 가비지콜렉션 알고리즘
Reference Counting Algorithm
Garbage의 Detection에 초점이 맞추어진 초기 Algorithm이다. 각 Object마다 Reference Count를 관리하여 Reference Count가 0이 되면 GC를 수행한다.
위 그림에서 a와 b는 각각 100, 99의 값을 갖는 Integer Object로 선언되어 있다. 각 Integer Object는 Referece Count가 1로 설정되어 있다. 이 상태에서 b = a로 변경하게 되면 a가 참조하고 있던 100의 값을 갖는 Integer Object는 참조가 없어지기 때문에 Reference Count가 0으로 감소하게 되고 GC가 수행된다.
이 방식은 Reference Count가 0이 될 때마다 GC가 발생하기 때문에 Pause Time이 분산되어 실시간 작업에도 거의 영향을 주지 않고 즉시 메모리에서 해제된다는 장점이 있으나 각 Object마다 Reference Count를 변경해 주어야 하고 참조를 많이 하고 있는 Object의 Reference Count가 0이 될 경우 연쇄적으로 GC가 발생할 수 있는 문제가 있고 Reference Count의 관리 비용도 크다. 또한 Linked List와 같은 순환 참조 구조에서 Memory Leak이 발생할 가능성도 크다.

3. 동시성(concurrency), 병렬성(paralㅣelism)

goroutine은 concurrency를 위해 go runtime에서 직접 관리하는 lightweight 스레드입니다.
고루틴은 go 가상머신 위에서 수행되는 스레드이다.
고루틴은 다른 go 루틴 존재하지 않을 시 main goroutine에서만 실행되고
다른 go루틴 실행 시 동시에 같이 실행된다.

먼저 concurrency부터 이야기하면, 어떤 프로그램이나 알고리즘이 순서에 상관없이 동시에 수행될 수 있다면 concurrent하다고 말합니다.  예를 들어, 1부터 100까지 숫자를 더하는 과정을 생각해보면 숫자 100개를 여러 부분 집합으로 나눈 뒤 동시에 부분합을 구합니다. 그리고 이 부분합을 다시 더하면 원래 얻고자 하는 값을 얻을 수 있습니다. 이 때 이 알고리즘은 concurrent하다라고 말합니다.



그런데 이 알고리즘이 정말 물리적으로 병렬로 돌아갈지 아닐지는 이 알고리즘이 어떤 하드웨어 위에서 돌아갈지 알아야만 확답할 수 있습니다. 방금 이야기한 알고리즘이 멀티 프로세서 머신에서 돌아가야 병렬 실행된다라고 말할 수 있습니다. Parallel execution은 따라서 프로그램의 성질보다는 하드웨어의 성질입니다.



Concurrent한 프로그램은 싱글코어 머신에서도 분명히 돌아갑니다. 뮤텍스, 데드락은 싱글코어에서도 얼마든지 그 의미를 갖습니다. 멀티스레드 프로그램이 비록 물리적인 제약으로 싱글코어에서 시분할 형태로 돌아가지만 겉으로는 concurrent하게 작동한다고 속일 수 있습니다. 반대로 아무리 멀티스레드로 작성된 프로그램이라 하더라도 멀티코어가 아니라면 병렬로 작동한다고 말하지 못합니다.



OpenMP, MPI, CUDA 같은 프로그래밍 방법론은 병행 프로그래밍 보다는 병렬 프로그래밍이 옳은 표현합니다. 언급한 세 방법론 모두 물리적으로 제공되는 다양한 병렬 하드웨어를 활용하기 때문입니다.



멀티 스레드 프로그램에서 벌어지는 각종 버그를 concurrency bug라고 부르는데, 굳이 하드웨어가 반드시 병렬성을 지원하지 않더라도 논리적으로 발생하니까 concurrency라는 말이 옳습니다.



보통 프로그램에서 병렬성을 찾는다고 하지 병행성을 찾는다고는 말하지 않습니다. 약간 모호하기는 하나 결국 물리적으로 병렬 실행이 가능한 코드를 찾는 것이니 병렬성이 더 합리적으로 보입니다. 어떤 함수에 락을 무식하게 크게 걸면 병행성(concurrency)가 나빠진다고 말합니다. 병렬성이 나빠진다고는 말하지 않습니다.



프로세스(process)란?
프로세스(process)란 단순히 실행 중인 프로그램(program)이라고 할 수 있습니다.

즉, 사용자가 작성한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것을 말합니다.

이러한 프로세스는 프로그램에 사용되는 데이터와 메모리 등의 자원 그리고 스레드로 구성됩니다.

스레드(thread)란?
스레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미하고 프로세스의 실행단위입니다.

모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행합니다.
프로세스와 같이 실행, 준비, 대기 등의 실행 상태를 가지며
실행 상태가 변할때마다 쓰레드 문맥교환(context switching)을 수행한다.
각 쓰레드별로 자신만의 스택과 레지스터를 가진다.

프로세스 - 레지스터, 메모리(힙, 스태틱, 코드, 스택), 쓰레드(레지스터, 스택)N개... -> 여기서 쓰레드가 가지는 스택은 프로세스가 os에게 할당받는 메모리 내의 스택을 관리하는것.


또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process)라고 합니다.

프로세스는 os로부터 메모리, io장치를 할당받고 쓰레드는 프로세스가 할당받은 메모리, io장치를 공유하며 일을한다.
여기서 일을할 때 com자원 최대활용위해 병렬적으로 일하게 만들어야하는데
해당 영역을 멀티 쓰레드 프로그래밍의 영역이다.
언어에서 병렬성이라고 불리는 대표예가 쓰레드이다. 따라서 쓰레드는 기계기반적인 단어라고 할 수 있다

4. 모듈화
코드 재사용 및 코드 유지보수성 향상을 위해서 모듈을 사용하는것
모듈이란 독립적으로 재활용될 수 있는 소프트웨어 덩어리를 말한다
하나의 모듈은 자신을 사용하기 위한API제공하며, 자신이 포팅되기 위한 명확한 환경 나열할 수 있어야함.

5. 컴파일속도 향상
Go 언어는 C, C++과는 달리 헤더 파일이 없고, 소스 코드를 패키지화하여 변경된 부분만 컴파일하므로 컴파일 속도가 빠릅니다.
 또한, 문법적으로도 복잡한 요소를 최대한 줄여 컴파일 속도에 유리하게 설계했습니다.

2) go 시작하기
중괄호, 들여쓰기 ,세미콜론, 주석 ,gofmt ( go 소스코드를 출력하는것 ) 

3) 타입
실수 ,복소수 , 정수, 바이트 ,룬 ,


실수표기 1.3e+10 = 1.3 x 10^10 (-의경우 10^-n)
12.345E+3 = 12345.0
또한 실수의 경우 반올림해서 10.0 같은 값이 존재 실제로는 .0000000000000004 같이 부정확
따라서 math 를 import 하여서 abs 함수 사용해서 비교해야함
또한 %연산 불가.
실수 / 실수 = 실수




정수표기 
10, -1, 073(8진), 0x104(16진)
쉬프트 연산또한 가능한데 << 나 >>으로 표기 쉬프트한 값만큼 2^n의 연산
<<일시 곱연산 >>일시 나눗셈 ^은 비트반전연산자
또한 uint32 -> uint16으로 타입변환시 넘치는값 버린다.
ex) var a uint8 = 128
    var b uint32 = 80000
a - uint16(b) = 128 - 2^16
음수 %연산시 나머지또한 음수.
정수 / 정수 = 정수
또한 int 는 운영체제에 따라서 다르다 32비트 = int32, 64bit = int64
int는 2의보수형태를 띈다.
int는 덧셈 시오버플로우시 최상위 비트인 부호비트가 1로바뀌면서 음수표현
uint는 덧셈 시 오버플로우 시 0부터 다시시작
int는 곱셈 시 덧셈처럼 곱한 수 만큼 음수표현 ( -1 부터 )
uint 또한 곱셈 시 덧셈처럼 곱한 수 만큼 양수표현 ( 0부터 )

바이트 uint8 크기 but 서로 변경은 불가
16진수, 문자값 주로저장 바이너리파일에서 데이터 읽고 쓰거나 암호 암,복호화시 사용

룬 int32 크기
utf저장시 사용
작은따옴표안에 그대로 문자적거나, '\uaa' 또는 '\U000000aa'같이 표기
소문자는 우항부터 채우기, 대문자는 16진수 8문자로 맞춰야함

비교연산 시 부울, 숫자, 스트링 모두 같은타입끼리는 비교가능 so ==, != 연산자 등.. 사용가능
다른타입끼리는 비교x int8, int32 같이..

타입 곱셈 출력할 때
uint8의 최대값 255 + 1 한다면? 100000000이 되고 8비트까지 출력이 되므로 0 출력
255 * 2 한다면? 510이 되고 111111110이 되며 8비트까지 출력하므로 254가 출력된다.
int8 최대값 127 + 1한다면? 부호비트가 바뀌고 -127이 된다.
127 * 2 한다면? 01111111이고 254는 11111110이 된다. 따라서 -2가되는데 질문올렸다.

정수 정리
정수엔 2가지 종류 존재한다.
int, uint 그중에서도 4개씩 나뉘는데 8, 16, 32, 64비트로 나뉜다. 물론각 타입 사이즈 다르고 서로 다른타입으로 취급해 연산불가 비트언급하지않을 시 하드웨어에따름.
룬은 unicode 표현위한 32비트 int형이지만 두 타입은 비교불가하다.
하지만 형변환을 해주면 연산가능.
마지막으로 uintptr 존재한다. 포인터 값을 가지는 타입인데, 실제로 포인터를 저장하는게아니라 주소를 직접저장하기때문에 보안적으로 좋지않다.
signed 정수는 2의보수 형태를 띈다. 최상위비트에는 부호비트가있고, 범위는 2^n-1 ~ 2^n-1 - 1 까지이다.
int8의 범위는 -128 ~ 127 까지이다.
정수에 적용 가능한 연산자 종류는 다음과 같다.
5* / % << >> & &^
4+-|^
3== != < <= > >=
2&&
1||
앞의 숫자는 연산자 우선순위이며 숫자가 높을수록 먼저 계산한다.
우선순위가 같은 연산자가 존재할 경우 좌->우로 연산한다. 또는 연산자 순위를 정해주기 위해선 괄호로 묶을 수 있다.
해당 연산 중 %는 부동소수점에만 적용가능
go언어에선 다른 언어와 다르게 음수에 나머지 연산% 적용할 시 나머지가 음수로 나온다.
연산자의 행동은 피연산자가 무슨 타입인가에 달렸다.
5 / 4는 1이지만 5.0 / 4.0 은 1.25이다.
정수 나눗셈은 소수점 이하 자리들은 0으로 바꾸기 때문이다
산술 연산의 결과로 signed든 unsigned이든 해당 타입에서 표현할 수 있는 비트보다 더 많은 bit를 가질 경우, overflow라고 부른다.
맞지않는 고차비트는 버려진다. 만약 원래의 값이 signed 타입이라면 부호비트가 1로 바뀌면서 결과는 음수로 변할 수 있다. 
예시
var a uint8 = 255
var b int8 = 127
fmt.Println(a * 2)	// 254 		255 * 2 = 510 binary 11111110 최상위비트 1 버리고 11111110 즉 254
fmt.Println(b * 2)	// -2 binary 11111110 부호비트 1이므로 2의보수 연산 10000010 
fmt.Println(b * 3)	// 125 binary 101111101 부호비트 포함 01111101 양수이므로 1111101 = 125
fmt.Println(b + 1)	// -128 2진법 01111111 + 1 = 10000000 부호비트 1으로 바뀌고 8비트이므로 값 버리지 않음.

두 정수타입이 같을 시 이진비교연산자를 사용해 비교가 가능하다.


정수 비교연산
==, !=, < <=, >, >=

단항연산 +, -
정수의 경우, +x는 0+x의 속기, -x 는 0-x의 속기
부동소수점의 경우 +x, -x 는 그저 x와 x의 부정(not)이다.

비트연산
&, |, ^(XOR), &^, << , >>
이들 중 처음 4명은 산술 운반이나 부호의 개념이 없는 비트 패턴으로 처리한다.
^는 두 피연산자의 연산자가 아닌 단항에 접두사로 들어갈경우 부정not 의 연산을 한다.
IE. &^ = AND NOT

쉬프트 연산
쉬프트 연산은 x << n, x >> n 같은 형태로 사용한다.
x는 int, uint 상관없지만, n은 이동할 비트 위치의 수를 결정하며 uint 타입이어야한다.
uint의 경우 좌쉬프트연산은 0으로된 비트를 1로 채운다. 우측연산 또한 같은 동작을한다.
int의 경우 우측쉬프트 연산은 빈 비트를 부호 비트의 복사본으로 채운다.
이러한 이유로 비트 패턴을 다룰때는 uint를 사용해야 한다.

음수 int의 우측쉬프트가 항상 -1인이유:
우측 쉬프트연산자는 나눗셈을 하지 않음.
 그들은 그들이 해야 할 일을 한다. 즉, 비트를 바꾼다. 특히 우측 시프트 운영자는 다음과 같이 한다.
1.오른쪽에서 시작하는 각 비트에 대해 해당 값을 왼쪽에 있는 값으로 설정하십시오.
2.왼쪽에 아무것도 없는 가장 왼쪽 비트는 현재 가치를 유지한다.

만약 110....101 우측쉬프트? -> 111...10
SO 최하위 비트는 소실되고 최상위 비트의 복사본으로 채워진다.
이 현상은 신호 전파(sign prepagation)라고 불린다.
왜냐면 음수인 정수에선 최상위 비트가 부호비트라고 불리는 비트로 채워져 양수인지 음수인지 구별하기 때문이다.

음수는 2의 보수로 저장된다. 32비트 운영체제에서 -x는 2^32 - x 로 저장된다.
이것은 1000....000(32개의 0)에서 1을 빼는것과 동일하기 때문에 111....111(32개의 1)으로 저장된다.
따라서 음수인 정수에서 우측 쉬프트연산을 아무리 하더라도 -1인 이유이다.
또한 이것은 비트패턴을 다룰 때 uint 산술타입을 사용해야하는 이유이다.

ie. var a int8 = -8	
-8 = 10001000 = 11110111 = 11111000 >> 1 = 11111100 >> 1 = 11111110 >> 1 = 11111111
			
오른쪽 시프트와 나누기 2의 차이는 시프트가 홀수 및 짝수에 대해 동일한 결과를 준다는 것이다.
나누기의 경우 3 / 2 = 1 4 / 2 =  2 이지만
그래도 나눗셈의 관점에서 보고싶다면 %연산자로 생각시 편하다
https://stackoverflow.com/questions/26821728/why-does-right-shifting-1-always-gives-1-in-php

비록 go에서 제공하는 uint가 숫자와 산술에 사용될 수 있지만 의도적으로 int형을 사용해야할때가 있다.
예를들면 음수로 넘어가지 않는 조건을 가진 배열의 범위같은..
그렇기 때문에 built-in 함수인 len()함수 사용시 리턴값은 int형이다.
medals := []string{"gold", "silver", "bronze"}
for i := len(medals) - 1; i >= 0; i-- {
fmt.Println(medals[i]) // "bronze", "silver", "gold"
}
만약 저 반복문에서 len이 uint형이라면 i가 0이 된 후 i-1을 하면 i의 최대값인(운영체제에 따라서 다르다.) 2^32 - 1이나 2^64 - 1이 나왔을것이다.
따라서 배열(slice)범위 밖의 원소를 참조하려 했으므로 컴파일 시 오류가 발생하게된다.
이 때문에 uint는 비트패턴을 다루는 연산이나 특정 연산시 사용한다.

모든타입 T에 대해서 허용가능한 범위에서 변환(convert)연산 T(x)는 값 x를 타입 T로 변환시킨다.
대부분의 정수간 타입변환 연산에서 값손실은 일어나지 않지만 타입 T보다 큰값이 x에 들어올 시 넘치는 값은 버려진다.
또한 부동소수점 타입에서 정수간의 변환에서도 소수점아래의 값은 버려진다.
f := 3.141 // a float64
i := int(f)
fmt.Println(f, i) // "3.141 3"
f=1.99
fmt.Println(int(f)) // "1"

어떤 사이즈 타입의 정수라도 8진수로 표현할 수 있다.
표현방법은 선언이나 할당 시 맨앞에 0을 붙여주면된다. IE) 0666, 0764..
또한 16진수로도 표현이 가능하다 맨앞에 0x를 붙이고 작성한다. IE) 0xdeadbeef, 0x1234567
대문자나 소문자나 같은 값을 표현하므로 따로 구분짓지않아도 된다.
최근에는 8진수는 특별한 목적을 위해서 주로 사용된다. IE) posix시스템..
%d, %o, and %x verbs, as shown in this example:
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
// Output:
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF

마지막으로 룬타입은 유니코드의 표현에서 주로 쓰이거나 단문 인용구 ' '사이에 넣어서 문자를 표현할 때 쓰는 정수타입이다.
ascii := 'a'
unicode := 'D'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii) // "97 a 'a'"
fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 D 'D'"
fmt.Printf("%d %[1]q\n", newline) // "10 '\n'"


3.2 부동소수점
go는 2개의 소수제공 float32, 64 
그들의 수학적 특성은 현대의 모든 CPU에 사용되는 IEEE754 표준에서 받아온것.
IEEE 754는 전기 전자 기술자 협회(IEEE)에서 개발한 컴퓨터에서 부동소수점을 표현하는 가장 널리 쓰이는 표준이다.
 ±0 등의 수와 무한, NaN 등의 기호를 표시하는 법과 이러한 수에 대한 연산을 정의하고 있다. 

부동소수점의 한계는 math패키지에서 찾을 수 있다.
math.MaxFloat64,32에서 찾을수 있다.
32의 경우 표현가능한 가장 큰 수는 3.4e38이고 64의 경우 1.8e308이다.
f32에서 6자리ㅜㅅ자까지 근삿값을 낸다. 64의 경우 15자리까지.
표현가능한 가장작은 양의실수는 1.4e-45 / 4.9e-324이다.

주로 64가 선호되는데 32를 사용하면 정확히 나타낼 수 있는 최소의 정수는 크지않고
그렇게 되면 조심스레 다루지 않는다면, 연산 간 빠르게 오류가 축적되기때문.


var f float32 = 1 << 24
f == f + 1 // true
왜이럴까?
이유는 다음과 같다
IEEE754에 따르면 32비트 부동소수점은
부호비트, 8비트의 지수(-127바이어스), 23비트의 지수를 가진다.
10진수 0.000123은 0.123e-3으로 표현되고 -3은 지수, .123을 가수라고 한다
어쨋든 2^24 2비트표현 = 1 0000 0000 0000 0000 0000 0000
2^24 + 1 = 1 0000 0000 0000 0000 0000 0001 -> 가수부로 갈때 1 잘림

부동소수점은 %g를 통해서 꽤나 정확하게 출력가능.
테이블안의 값이라면 %e(exponent) 또는 %f(no exponent)폼이 더 정확하다.
math패키지 내의 Exp함수를 통해서 출력해보자
	var a float32 = 1.1234567891
	var b float32 = 1.2345678912
	var c float32 = 1.3456789123

	fmt.Printf("%g %e %f", a, b, c)
// 1.1234568 1.234568e+00 1.345679




for x := 0; x < 8; x++ { 	
fmt.Printf("x = %d eA = %8.3f\n", x, math.Exp(float64(x)))	// %8.3f로 오른쪽 8개 숫자까지 깔끔하게 맞춤.

x=0 eA = 1.000
x=1 eA = 2.718
x=2 eA = 7.389
x=3 eA = 20.086
x=4 eA = 54.598
x=5 eA = 148.413
x=6 eA = 403.429
x=7 eA = 1096.633

math 패키지 사용시 다양하고 유용한 수학적 기능 사용가능. IEEE754에 정의된 특이한 값을 탐지할 수 있는데
그 예시로 NAN, INF, -INF, 0, -0 존재
var z float64	// zero value인 0으로 설정
fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
fmt.Print
nan := math.NaN() 사용해 비교연산자 사용해 nan 판단또한 가능.

3.3 부울린타입
2가지 값만 가질 수 있는 타입이다. t/f
if나 for문에서 조건문에서 사용한다.
==나 < 같은 비교연산자에서도 사용한다.
단항 연산자인 !은 부정의 의미다
(!true == false) == true는 true이다.
우리는 if문이나 for문에서 x == true를 x로 줄여서 작성할 수 있다. ex) if (x == true) <=> if x
부울형식은 &&, ||와 결합가능하며 &&은 ||보다 우선순위를 가진다. &&은 부울 곱셈연산이기때문.
부울타입으로부터 숫자 값으로의 암시적인 형변환 0,1 또는 그 반대는 불가능하다.

It mig ht be wor th writing a conversion function if this operat ion were needed often:
// btoi returns 1 if b is true and 0 if false.
func btoi(b bool) int {
if b {
return 1
}
return 0
}
The inv ers e op erat ion is so simple that it doesn’t war rantafunction, but for symmetr y here it
is:
// itob reports whether i is non-zero.
func itob(i int) bool { return i != 0 }

3.4 스트링
스트링은 변경불가능한 바이트의 순서이다. 값이 0인 바이트를 포함해 임의의 데이터가 포함될 수 있음.
하지만 대개 인간이 읽을 수 있는 텍스트로 표현됨.
스트링은 보통 utf-8으로 인코딩된 유니코드 포인트(rune)의 순서로 해석된다.
코드포인트란? 유니코드 표현 시 사용하는 일련의 표현법.
예를 들면 유니코드 韓의 코드 포인트는 U+97D3

built-in len함수는 스트링 내의 바이트 수를 리턴한다.
또한 인덱스 연산자 s[i]는 i번째 스트링의 바이트를 검색합니다.
s := "hello, world"
fmt.Println(len(s)) // "12" 참고로 len함수의 리턴값은 uint가 아닌 int형이다.
fmt.Println(s[0], s[7]) // "104 119" ('h' and 'w')

문자열의 i번째 바이트는 반드시 문자열의 i번째 문자는 아니다. 
왜냐하면 비-asci 코드 포인트의 utf-8 인코딩은 2바이트 이상의 바이트를 필요로 하기 때문이다.

서브스트링 연산자 s[i:j]는 원래의 스트링으로부터 구성된 새로운 스트링을 산출한다.
여기서 j의 인덱스는 포함되지 않는다.
여기서 i, j는 포함되지 않아도된다.
fmt.Println(s[:5]) // "hello"
fmt.Println(s[7:]) // "world"
fmt.Println(s[:]) // "hello, world"
+ 연산자는 두 스트링을 연결시켜 새로운 스트링을 만든다.
fmt.Println("goodbye" + s[5:]) // "goodbye, world"

스트링은 비교연산자에 의해서 각 바이트순서 대 바이트로 비교가능하다.
결과는 자연수의 편찬 순서에 의해 결정된다.

스트링의 값은 변경불가하다.
스트링에 저장된 바이트의 순서는 절대 변경될 수 없다.
하지만 새로운 값을 스트링 값에 할당할 순 있다. 또는 스트링을 덧붙여서 새로운 스트링을 만들수 도 있다.
s := "left foot"
t := s
s += ", right foot"
s = "new foot"

스트링은 변경불가하기 때문에 생성자가 스트링 데이터의 임의 위치의 값을 변경하려고 하면 허용되지않는다.
s[0] = 'L' // compile error: cannot assign to s[0]
	
변경불가성은 두개의 스트링에 공유하는 같은 근본의 메모리를  안전하다는걸 뜻한다 
따라서 스트링을 복사할 때 소비하는 메모리의 비용을 줄여주는 역할을한다.(string의 어떠한 길이에도)
비슷하게 strings와 substring(s[:7]같은..) 아마 안전하게 같은 데이터를 공유가 가능할것이다.
그러므로 서브스트링 연산자 또한 메모리 비용이 저렴해진다.
어떠한 	경우에도 새로운 메모리는 할당되지않는다.
다음 그림은 두개의 서브스트링이 같은 메모리(근본 바이트 배열)를 공유하는것을 나타낸다.

3.4.1 스트링 리터럴
스트링 값은 string 리터럴로 쓰여질 수 있다. ie) "hello"
왜냐면 go 소스파일은 항상 utf-8로 인코딩되키 때문이다.
또한 go 텍스트 스트링은 관례로 utf-8로 해석된다. 그렇기때문에 우리는 유니코드포인트를 스트링 리터럴로 넣을 수있다.
큰따옴표 스트링리터럴에서 \으로 시작하는 이스케이프시퀀스는 임의적인 바이트값을 스트링에 넣을 수 있다.
ascii에서 다루는 es는 다음과 같다.
\a ‘‘aler t’’ or bel l
\b backsp ace
\f form feed
\n ne wline
\r carriage retur n
\t tab
\v vertic al tab
\' single quote (on ly in the rune lit eral '\'')
\" double quote (on ly wit hin "..." literals)
\\ backsl ash

임의적인 바이트는 리터럴 스트링에서 16, 8진수를 사용해 포함될 수 있다.
16진수 이스케이프틑 \xhh, 정확히 두개의 16진수로만 표현이 된다.
8진수는 \ooo으로 표현 3개의 8진수로 표현하며 \377을 넘어가지 않는다.
두 표현방식 다 지정된 값을 가진 단일 바이트를 의미한다.
나중에 우리는 유니코드 코드포인트를 스트링 내에서 어떻게 수적으로 다루는지 볼 것이다.

원시 string 리터럴은 백쿼트를 ""대신 백쿼트를 사용해 표현한다.
원시 문자열 리터럴 내에서는 이스케이프 시퀀스가 처리되지 않는다.
 백슬래시, 뉴라인 등 문자 그대로 내용을 취하기 때문에
 원시 문자열 리터럴이 프로그램 소스의 여러 줄에 퍼질 수 있다.

유일한 프로세싱은 캐리지 리턴이 삭제되어 문자열의 값이 텍스트 파일에 캐리지 리턴을 넣는 것을 포함하여 
모든 플랫폼에서 동일하도록 하는 것이다.

원시 스트링 리터럴은 표준 표현에 편한 방식이다. 많은 백슬래시를 가지는 경향때문.
그들은 html템플릿, json리터럴, 커맨드 상용메시지같은곳에서 많이 사용된다.

3.4.2 유니코드

3.4.3 utf-8

UTF-8은 Universal Coded Character Set + Transformation Format – 8-bit 의 약자이다.
utf-8은 바이트스트림으로 유니코드 코드 포인트를 인코딩하는 방법이다(정수 범위 0 에서 10FFFF까지) 
인코딩은 문자나 기호들의 집합을 컴퓨터에서 표현하는 방법

//utf-8은 바이트로써 유니코드 코드 포인트의 변수길이 인코딩이다.
utf-8은 go 개발자인 켄 톰슨, 로브 파이크에 의해 고안되었다.
utf8은 룬 타입을 사용하고 각 크기는 1~4바이트이다.
아스키 문자의 경우는 1바이트이고 나머지는 보통 2,3 으로 사용한다.
고차 0은 7비트 ASCII를 나타내며, 각 런은 1바이트만 사용하므로 기존의 Ascii와 동일하다.
따라서 0 ~ 127까지의 아스키코드를 나타낼 수 있다.//

--utf-8이 해결한 문제--
미국의 키보드는 종종 101개의 기호를 만들 수 있는데, 
이것은 101개의 기호가 대부분의 영어 텍스트에 충분하다는 것을 암시한다. 
7비트는 2^7 = 128 이후 이러한 기호를 인코딩하기에 충분할 것이며, 
그것이 바로 ASCII가 하는 것이다. 
컴퓨터가 2의 검정력인 크기의 그룹에서 비트로 작동하기 때문에 8비트로 각 문자를 나타내지만, 
첫 번째 비트는 필요하지 않기 때문에 항상 0이다. // 01111111 -> 128개의 문자
확장 ASCII는 ASCII의 왼쪽 전체 공간을 사용하여 더 많은 문자를 인코딩한다. // -> 11111111 -> 256개의 문자

총 256개의 글자가 일부 사용자에게 잘 전달될 수 있지만, 
예를 들어 중국어 같은 것을 나타내기 시작하지는 않는다. 
유니코드는 처음에 문자를 나타내기 위해 하나의 바이트 대신 2바이트를 사용하기를 원했는데, 
이것은 216 = 65,536 가능성을 허용하며, 세계의 많은 쓰기 시스템을 포착할 수 있었다. 
하지만 전부는 아니었고, 그래서 유니코드는 4바이트로 확장되었다.

각 문자에 대해 2바이트의 영어 텍스트를 저장한다면 절반의 공간이 0을 저장하느라 낭비될 것이다. 
그리고 한 글자당 4바이트를 사용한다면 공간의 4분의 3이 낭비될 것이다. 
어떤 종류의 인코딩이 없다면 영어 시험을 포함한 모든 파일은 필요한 것보다 두 배나 네 배나 더 클 것이다. 
그리고 영어뿐만 아니라 ASCII로 나타낼 수 있는 모든 언어.

UTF-8은 ASCII 텍스트 파일이 스스로 인코딩되도록 유니코드를 인코딩하는 방식이다. 
모든 바이트 ASCII가 사용하지 않는 초기 비트 외에 낭비되는 공간 없음. -> 11010101 10000000 -> 초기비트 110, 10 제외한 나머지는 유니코드 표현에 사용한다.
그리고 당신의 파일이 대부분 ascii고 몇몇 문자가 non-ascii일 경우 non-ascii는 당신의파일을 조금 더 크게 만든다.
유로 기호 €(U+20AC)를 사용하고 싶다고 해서 
갑자기 모든 캐릭터가 두 배, 네 배의 공간을 차지하도록 할 필요는 없다.
ie) "€abcdddcdcdcdcd" 라는 문장이 있을 때 모든 문자를 4바이트 유니코드가 되진 않는다.

utf-8 작동원리

ASCII 문자의 첫 번째 비트는 0으로 설정되므로 첫 번째 비트가 1로 설정된 바이트는 사용되지 않으며 
특별히 사용할 수 있다.
ascii 코드는 0 ~ 127까지의 값 가지므로 10000000비트 가진 아스키 코드는 코드가 ascii인지 유니코드인지 구분한다.

소프트웨어 판독값 UTF-8이 1로 시작하는 바이트와 마주칠 때 0에 도달하기 전에 1이 따르는 횟수를 계산한다. 
예를 들어, 110xxxxx 형식의 바이트에는 초기 1 다음에 하나의 바이트가 있다. 
n은 초기 1과 처음 0 사이의 1의 숫자가 되도록 한다. 
이 바이트에 남아 있는 비트와 다음 n바이트의 일부 비트는 유니코드 문자를 나타낸다. 
우리가 나중에 알게 될 이유로 n이 3보다 클 필요는 없다. 
즉, UTF-8을 사용하는 유니코드 문자를 나타내는 데 최대 4바이트가 소요된다.

그래서 110xxxxx 형식의 바이트는 유니코드 문자의 처음 5비트가 이 바이트의 끝에 저장되고 
나머지 비트는 다음 바이트로 들어온다고 말한다.

ie) 128 ~ 2047 유니코드의 표현은 110xxxxx ~ 10xxxxxx이다. 
초기 비트 110으로 범위는 U+0080 ~ U+07FF 까지인것을 확인하고 
110xxxxx에서 처음 5비트로 바이트로 저장한다.
나머지 비트는 다음 바이트 10xxxxxx에서 x안에 저장된다.
U+00C0인 À의 UTF-8인코딩된 유니코드 값은 11000011 10000000 이다.

예시)
0xxxxxx runes 0−127 (ASCII)
110xxxxx 10xxxxxx 128−2047 (values <128 unus ed)	// 이경우 n = 1 이다.
1110xxxx 10xxxxxx 10xxxxxx 2048−65535 (values <2048 unus ed)	// n = 2
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536−0x10ffff (other values unus ed) // n = 3

다중 바이트에 걸쳐 퍼진 문자 시작 부분을 알리는 초기 바이트에 이어 비트는 10xxxxxx 형식의 바이트로 저장된다. 
멀티바이트 시퀀스의 초기 바이트는 2개의 1비트로 시작하므로 모호함이 없다: 최소의 멀티바이트는 110으로 시작함.
10으로 시작하는 바이트는 새로운 멀티바이트 시퀀스의 시작을 표시할 수 없다. 즉, UTF-8은 자칭이다.

유니코드 문자는 표면적으로는 32비트 숫자지만, 
여기서 설명하는 이유로 유니코드 문자를 인코딩하는 데는 실제로 최대 21비트가 필요하다. 
이것이 멀티바이트 시퀀스의 시작 부분에서 초기 1을 따르는 1의 숫자인 n이 1, 2, 3만 있으면 되는 이유다. 
UTF-8 인코딩 체계는 n = 4, 5, 6을 허용하도록 확장할 수 있지만 이는 불필요하다.

UTF-8을 사용하면 일반적인 ASCII 파일을 가져다가 UTF-8로 인코딩된 유니코드 파일로 간주할 수 있으므로 
UTF-8은 공간면에서 ASCII만큼 효율적이다. 
하지만 시간적인 면에서는 그렇지 않다. 
소프트웨어가 파일이 실제로 ASCII인 것을 알고 있다면, 
멀티바이트 시퀀스의 첫 번째 바이트인지 확인할 필요 없이 각 바이트를 액면값으로 가져갈 수 있다.

그리고 일반적인 ASCII는 합법적인 UTF-8이지만 확장된 ASCII는 그렇지 않다. 
그래서 확장된 ASCII 문자는 이제 이전에는 두 바이트를 사용하곤 했다. 
나의 이전 게시물은 UTF-8 인코딩된 파일을 확장된 ASCII 파일로 
해석하는 소프트웨어로 인해 발생할 수 있는 혼동에 관한 것이었다.

-------------유니코드 매핑--------------------



정리
1. 모든 아스키 파일은 이미 UTF-8파일이다.
128개의 유니코드 코드 포인트들은 7비트 아스키 문자셋이다.
그리고 UTF-8은 그들의 1바이트 인코딩을 보존한다.

2. ASCII 바이트는 항상 UTF-8 파일로 표시된다. 그것들은 결코 다른 UTF-8 시퀀스의 일부로 나타나지 않는다.
ASCII가 아닌 모든 UTF-8 시퀀스는 하이 비트 세트가 있는 바이트로 구성되므로
UTF-8 파일에서 바이트 0x7A가 보이면 문자 z를 나타내는 것을 확인할 수 있다.

3. ASCII 바이트는 항상 UTF-8 파일에서 그 자체로 표현된다. 그것들은 멀티바이트 UTF-8 시퀀스 안에 숨겨질 수 없다.
ASCII z 01111010은 2바이트 UTF-8 시퀀스 11000001 101110으로 인코딩할 수 없다.
코드 포인트는 가능한 최단 시퀀스를 사용하여 인코딩해야 한다.
결과적으로는 디코더가 유효하지 않은 것으로 장황한 시퀀스를 감지해야 한다는 것이다.
실제로 디코더는 유니코드 대체 문자인 코드 포인트 FFFD를 텍스트 처리를 중지하지 않고 
유효하지 않은 UTF-8 시퀀스의 디코딩으로 사용하는 것이 유용하다.

4. utf-8은 자가 동기화한다.
10xxxxxx 형식의 바이트를 연속 바이트라고 부르자.
모든 UTF-8 시퀀스는 연속 바이트가 아니며 0 또는 그 이상의 연속 바이트가 뒤따른다.
임의 지점에서 UTF-8 파일을 처리하기 시작하면 
UTF-8 인코딩의 시작점은 아닐 수 있지만, 
비연속 바이트를 찾을 때까지 연속 바이트를 건너뛰는 것을 쉽게 찾을 수 있다.

5.하위 문자열 검색은 바이트 문자열 검색일 뿐이다.
속성 2, 3, 4는 올바르게 인코딩된 UTF-8 문자열이 주어진 경우, 
이러한 바이트가 더 큰 UTF-8 텍스트에 나타날 수 있는 유일한 방법은 
동일한 코드 포인트를 나타내는 것이다.
그래서 당신은 strchr이나 strstr와 같은 시간 검색 기능에서 
어떤 8비트 안전 바이트를 사용하여 검색을 실행할 수 있다.

6. 8비트 파일을 안전하게 처리하는 대부분의 프로그램은 UTF-8을 안전하게 처리할 수 있다.
이것은 또한 속성 2, 3, 4에서도 나타난다. 
나는 "대부분" 프로그램을 말한다. 
왜냐하면 바이트당 한 개의 문자를 기대하는 바이트 시퀀스를 분해하는 프로그램은 
올바르게 동작하지 않을 것이기 때문이다. 하지만 극소수의 프로그램만이 그렇게 한다.

7. UTF-8 시퀀스는 코드 포인트 순서로 정렬된다.
위의 표에 있는 인코딩을 검사하여 이것을 확인할 수 있다.
이는 조인, ls, 정렬(옵션 없음)과 같은 유닉스 도구가 특별히 UTF-8을 처리할 필요가 없다는 것을 의미한다.

8. UTF-8에는 "바이트 순서"가 없다.
UTF-8은 바이트 인코딩이다. 그것은 작은 엔디안이나 큰 엔디안이 아니다.
유니코드는 UCS-2 또는 UTF-16과 같은 원시 16비트 값의 스트림의 바이트 순서를 결정하는 데 사용되는 
BOM(Byte Order Mark) 코드 포인트 FFFE를 정의한다.
UTF-8 파일에는 자리가 없다. 
일부 프로그램은 UTF-8 파일의 시작 부분에 UTF-8 인코딩된 BOM을 쓰는 것을 좋아하지만 이는 불필요하다.


고차비트가 11으로 시작하는 경우 utf-8에 따르고 나머지 비트들은 10으로 시작한다.
Unicode code points		UTF-8 encoding (binary)
00-7F	(7 bits)		0tuvwxyz
0080-07FF	(11 bits)	110pqrst 10uvwxyz
0800-FFFF	(16 bits)	1110jklm 10npqrst 10uvwxyz
010000-10FFFF	(21 bits)	11110efg 10hijklm 10npqrst 10uvwxyz

0xxxxxx runes 0−127 (ASCII)
110xxxxx 10xxxxxx 128−2047 (values <128 unus ed)
1110xxxx 10xxxxxx 10xxxxxx 2048−65535 (values <2048 unus ed)
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536−0x10f f f f (other values unus ed)

ㄱㄴㄷㄹ utf-8사용한 인코딩
11100011 10000100 10110001 
11100011 10000100 10110100 
11100011 10000100 10110111 
11100011 10000100 10111001

가변길이 인코딩은 즉각적인 인덱싱 to 접근 n-th 문자 of 스트링을 예방함.
하지만 utf-8은 보상해야 할 많은 바람직한 속성을 가지고 있다.
인코딩이 작고, 아스카이와 호환되며, 자가 동기화됨
3바이트 이하의 백업으로 문자의 시작을 찾을 수 있다.
그것은 또한 접두사 코드여서, 어떤 모호함이나 시선도 없이 왼쪽에서 오른쪽으로 분산될 수 있다.
어떤 rune의 인코딩도 다른 어떤 것의 하위 문자열이나 심지어 다른 것의 시퀀스인 만큼, 
앞의 문맥에 대해 걱정하지 않고 그것의 바이트만을 검색하여 rune을 검색할 수 있다.
1110 은 65535 ~ 110은 2048 ~ 11은 2048 ~ 이므로..

사전의 바이트 순서는 동일하다 유니코드 코드 포인트 순서와, 따라서 utf정렬은 자연스럽게 이뤄진다.
그들에겐 내장된 nul(zero)바이트가 없다.
내장된 nul 바이트가 없기 때문에 nul을 사용하여 문자열을 종료하는 언어를 프로그래밍하는 데 편리하다.

go 소스파일은 항상 utf-8로 인코딩된다. 그리고 u8은 go 프로그램에의해 다뤄지는 텍스트 스트링 인코딩 시 선호된다.
유니코드 패키지는 함수를 제공한다 개별적인 룬을 다루는 작업 시(숫자, 영문 구분하는 작업, 대소문자 변환작업 등)
그리고 unicode/utf8패키지는 utf8을 사용해 바이트를 인코딩, 디코딩 하는 함수를 제공한다.

많은 유니코드 문자들은 키보드로 작성하기 어렵고 비슷한문자는 구별하기 힘들다.
유니코드는 go 문자열 리터럴에서 탈출하여 숫자 코드 포인트 값으로 지정할 수 있다.
그들은 두개의 형식을 가진다. \uhhhh for 16bit, \uhhhhhhhh for 32bit -> 자주사용x
각각은 지목한다 특정 코드 포인트 utf8 인코딩을.

"BF"
"\xe4\xb8\x96\xe7\x95\x8c"
"\u4e16\u754c"
"\U00004e16\U0000754c
// 6바이트짜리들.

4.1 배열

배열은 고정크기의 0개이상의 특정타입 가지는 원소의 순서이다.
go에선 slice 더 자주씀. why? 더 flexible 하고 유용함.
배열의 인덱스는 0부터 시작하는 기존 표기법사용
빌트인함수 len 사용시 배열의 원소 수 반환

var a [3]int // array of 3 integers
fmt.Println(a[0]) // print the first element
fmt.Println(a[len(a)-1]) // print the last element, a[2]

// Print the indices and elements.
for i, v := range a {
fmt.Printf("%d %d\n", i, v)
}

// Print the elements only.
for _, v := range a {
fmt.Printf("%d\n", v)

기본적으로 새 배열의 변수는 zerovalue로 초기화.
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2]) // "0"

배열 리터럴의 경우 [...]으로 기링 나타내기 가능
길이는 초기화 변수에 의해 결정.
q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int

배열의 사이즈는 타입의 한 종류임, 즉 [3]int, [4]int는 다르다는 뜻
사이즈는 무조건 constant 표현이어야한다. 그러므로 표현은 프로그램 컴파일 시 평가된다.
q := [3]int{1, 2, 3}
q=[4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int

리터럴 구문은 배열, 슬라이스, 맵, 구조체와 비슷하다.
특정 형태는 값의 순서에 따르고 인덱스, 값의 쌍을 특정짓는게 가능하다.
type Currency int
const (
USD Currency = iota
EUR
GBP
RMB
)
symbol := [...]string{USD: "$", EUR: "9", GBP: "!", RMB: """}
fmt.Println(RMB, symbol[RMB]) // "3 ""

이러한 형태로 지수는 임의의 순서나 생략되게 표현될 수 있다. 그전에 특정짓지 않은값은 zerovalue로 초기화된다.
r := [...]int{99: -1} r은 100개원소 가지고 99인덱스 원소값은 -1

배열의 원소가 비교가능한 타입이라면 배열 타입또한 비교가능.
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // "true false false"
d := [3]int{1, 2}
fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int

좀더 그럴듯한 예제로
crypto/sha256 패키지 내의 Sum256 함수는 SHA256 크립토그래픽 해쉬 또는 
일정한 바이트 슬라이스에 저장된 메시지의 digest를 생산한다.
digest는 256비트를 가진다. 따라서 이는 [32]byte의 자료형을 의미한다.
만약 두 digest가 같다면 대부분 두 메세지는 같다.
다이제스트가 다르면 두 메세지는 다르다.
x, X 의 SHA256방식으로 처리된 digest를 출력, 비교하는 예제.

import "crypto/sha256"
func main() {
c1 := sha256.Sum256([]byte("x"))
c2 := sha256.Sum256([]byte("X"))
fmt.Printf("%x\n%x\n%t\n%T\n", c1, c2, c1 == c2, c1)
// Output:
// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881
// 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015
// false
// [32]uint8
}


4.4 구조체
구조체는 데이터 타입들을 합산한 데이터 타입이다.
구조체 내의 각 값들은 필드라고 불린다.
다른 언어와 동일하게 구조체변수를 만들어서 접근이 가능하다.
type Employee struct {
ID int
Name string
Address string
DoB time.Time
Position string
Salary int
ManagerID int
}
var dilbert Employee

dilbert.Salary -= 5000 // dot 연산자를 이용해 변수dilbert의 개인 필드에 접근해 필드에 할당하는 방법

position := &dilbert.Position
*position = "senior" + *position	// position 포인터변수 만들어 dilbert의 Position 필드값 주소 받아온다.
// position의 값을 "seniore" + *position 해준다.

var employeeOfTheMonth *Employee = &dilbert
employeeOfTheMonth.Position += " (proactive team player) == (*employeeOfTheMonth).Position += " (proactive team player)"
포인터변수를 만들어서 다른 구조체변수를 받아와서 작업한느 경우.



[[[암호학 용어정리]]]

'a'가 암호화 되는 순서
'a' --> hash함수(SHA256방식) --> digest

- Cryptography는 ‘암호화 방식’, ‘암호화 기법’을 의미
  예를 들어, SHA256은 유명한 Cryptography
- Encryption은 원래의 평문을 암호화하는 작업 자체를 의미
  우리는 어떤 텍스트를 특정 Cryptography(가령 MD5)로 encrypt할 수 있고 
  다른 암호를 특정 Cryptography(가령 SHA256)으로 decrypt할 수 있다.

- Message: 암호학에서 ‘Message’는 암호화할 원래의 평문을 의미한다.
메시지는 그 길이가 다양(variable)할 수 있다.논문과‘a’라는 글자는 길이가 달라도 모두 암호화될 수 있는 message이다.
- Digest: ‘Digest’는 암호화나, 암호화된 메시지 자체를 의미한다.

- hash function
해시는 임의의 길이의 데이터를 고정된 길이의 다른 데이터로 매핑해주는 함수나, 그 결과 반환된 값을 의미한다. 

- 해시 함수는 반드시 단방향이어야 한다.
암호는 인간에게 중요한 정보를 숨기기 위해 사용한다. 
원 메시지는 공개되면 안 되지만 향후 키를 알고 있는 내집단은 복호화할 수 있어야 하기 때문에 
암호는 공개되는 경우가 많다. 이때 해시 함수가 양방향이라면 암호를 통해서도 
원 메시지를 해독할 수 있다는 의미가 되기 때문에 암호로서 의미가 없다. 

같은 암호(digest)를 갖는 서로 다른 메시지를 찾는 것이 전산학적으로 실행불가능해야 한다.(computationally infeasible)
만약 두 가지 이상의 서로 다른 메시지가 같은 암호를 갖는다면 이는 암호를 해독했을 때 두 가지 이상의 서로 다른 의미로 해석될 수 있다는 뜻이 된다. 당연히 이는 바람직하지 않다.
이때 왜 전산학적으로 실행불가능이라는 단서가 붙었을까? 뒤집어서, 같은 암호값을 갖는 서로 다른 메시지를 찾는 방법이 뭐가 있을까? 가장 무식하고 확실한 방법은 가능한 모든 메시지를 해시로 만들어서 이중 해시가 일치하는 메시지들을 찾는 것이다.(Bruce force) 어떤 암호화 알고리즘이든 이는 시도할 수는 있다. 하지만 전산학적으로 불가능하다. 유명한 암호화 방식은 SHA256은 256 비트의 길이를 갖는 digest를 반환하는데 이때 이 digest가 가질 수 있는 상태의 경우의 수는 
2
256
, 무려 78자리의 수다. 단순히 확률론적으로도 서로 다른 메시지가 같은 digest를 가지기는 매우 어렵고 컴퓨터로 계산하기도 어렵다.
따라서 해시 함수는 비대칭적(asymmetric)이어야 한다.