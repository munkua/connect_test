https://velog.io/@kimmachinegun/tags/golang golang 유용글 sync, pool
https://godoc.org go 문서
https://www.udemy.com/course/learn-go-the-complete-bootcamp-course-golang/?referralCode=5CE6EB34E2B1EF4A7D37
https://medium.com/@joongwon/jvm-garbage-collection-algorithms-3869b7b0aa6f gc 알고리즘
https://github.com/KennethanCeyer/learn-golang-kr/wiki go언어 깃허브
https://okky.kr/articles/community 
http://www.yes24.com/Product/Goods/44305533 코딩인터뷰 정복
https://jacking75.github.io/go_PerformanceTuning/ golang 성능튜닝
https://goodgid.github.io/What-is-Thread/ 쓰레드란?


https://velog.io/@kimmachinegun/tags/golang golang 유용글 sync, pool
https://godoc.org go 문서
https://www.udemy.com/course/learn-go-the-complete-bootcamp-course-golang/?referralCode=5CE6EB34E2B1EF4A7D37
https://medium.com/@joongwon/jvm-garbage-collection-algorithms-3869b7b0aa6f gc 알고리즘
https://github.com/KennethanCeyer/learn-golang-kr/wiki go언어 깃허브
https://okky.kr/articles/community 
http://www.yes24.com/Product/Goods/44305533 코딩인터뷰 정복
https://www.a-ha.io/questions/categories/3 질문자주올라오는곳

포트폴리오 작성하기 위해서 go로 좋은코드, 메모리 관리가 잘 되는 코드를 작성하고
백준 알고리즘에서 문제를 풀어 github에 업로드해보자

go는 다른언어처럼 여러개의 기본적인 구조가 모여 큰 프로그램을 빌드하고 변수는 값을 저장한다. 
이번챕터에선 기본구조 원소 go 언어 알아봄

go 함수, 변수, 상수, 타입, 문, 패키지의 이름은 간단한 룰을 따른다.
시작은 문자, 언더바로 시작하고 그 뒤에 아무숫자나 문자가 따른다.

go에는 25가지 키워드가 존재한다. (사진)
이 키워드는 변수나 상수의 이름으로 사용할 수 없다.
또한 int 나 true처럼 빌트인타입, 함수 등이 존재한다. (사진)
해당 이름들은 예약되지 않았으므로 선언시 사용이 가능하다.
만약 개체가 함수에안에서 선언되었으면 그 개체는 함수에 지역적이다.
만약 함수 밖에서 선언되었다면 해당 패키지를 가지 모든파일에 종속적이다.
이름의 첫번째 문자는 패키지의 경계에서 가시성을 결졍한다.	
만약 이름이 대문자로 시작하는 경우 이것은 외부적이다.
이것은 가시적이고 접근가능하단것을 뜻한다. 우리의 패키지의 밖에서 그리고 다른 프로그램의 파트에서도 참조 가능하다.
ex) Printf는 fmt패키지에속한다.
또한 외부에서 참조되는 함수는 대문자로 시작한다. ex)Printf는 fmt패키지 내부에 정의됨.
또한 줄임말보다는 의미가 명확하게 변수를 작명하는게 좋음
ex) for루프 시 i보다는 theLoopIndex처럼..

언어 스타일적으로 go언어는 2음절 이상의 단어에 낙타체를 사용한다.
음절사이에 언더바 보다는 대문자로 구분하는것을 선호한단뜻이다.
그러모르 스탠다드 라이브러리는 QuoteRuneToASCII나 parseRequestLine 같이 작명된 함수를 가진다.
여기서 HTML이나 ASCII는 항상 대문자로 사용해야하는 단어이다.
ex) HTMLEscape, escapeHTML

- 선언
선언은 프로그램 엔티티를 명명하고 그 속성의 일부 또는 전체를 명시한다.
선언에는 네가지 주 선언이 존재한다.

go에는 25가지 키워드가 존재한다. (사진)
이 키워드는 변수나 상수의 이름으로 사용할 수 없다.
또한 int 나 true처럼 빌트인타입, 함수 등이 존재한다. (사진)
해당 이름들은 예약되지 않았으므로 선언시 사용이 가능하다.
또한 외부에서 참조되는 함수는 대문자로 시작한다. ex)Printf는 fmt패키지 내부에 정의됨.
또한 줄임말보다는 의미가 명확하게 변수를 작명하는게 좋음
ex) for루프 시 i보다는 theLoopIndex처럼..

언어 스타일적으로 go언어는 2음절 이상의 단어에 낙타체를 사용한다.
음절사이에 언더바 보다는 대문자로 구분하는것을 선호한단뜻이다.
그러모르 스탠다드 라이브러리는 QuoteRuneToASCII나 parseRequestLine 같이 작명된 함수를 가진다.
여기서 HTML이나 ASCII는 항상 대문자로 사용해야하는 단어이다.
ex) HTMLEscape, escapeHTML

- 선언
선언은 프로그램 엔티티를 명명하고 그 속성의 일부 또는 전체를 명시한다.
선언에는 네가지 주 선언이 존재한다.
var, const, type, func
우린 여기서 변수 선언인 var를 살펴볼것이다.
go 프로그램은 .go 확장자로 하나 또는 그 이상의 파일로 저장된다.
각 파일은 파일의 일부라는것을 나타내는 패키지 선언으로 시작한다.
패키지 선언은 어떤 import 선언에 따른다. 그리고 타입, 변수, 상수, 함수 패키지레벨 순서의 선언에 따른다.
예를들어 해당 프로그램은 상수, 함수, 2개의 변수를 선언한다.
(예시코드)
상수 bolingF는 패키지 레벨 선언이다.
반면 c,f 변수는 main 함수의 지역변수이다.
패키지레벨 개체의 이름은 소스코드 뿐만 아니라 해당 패키지를 선언한 모든 go 파일의 범위에서 볼 수 있다.
대조적으로 지역내에서 선언된 c,f 변수의 범위는 main함수내이다.
함수선언은 이름, 매개변수 리스트(함수 호출자에 의해 정의된 변수들), 추가적인 결과의 리스트, 함수가 어떤 동작을 할지 정의한 문(statement)를 가진 함수몸체로 선언된다.
결과 리스트는 함수가 아무것도 리턴하지 않을 시 배제된다.
함수는 첫 문(statement)부터 리턴문 또는 함수의 마지막 부분을 만날때 까지 실행한다.
실행이 끝난 뒤 제어권, 결과는 함수 호출자에게로 넘어간다.
(예시)함수 fToC는 화씨 온도를 섭씨 온도로 변환하는 기능을 하는 캡슐화된 함수이다.
여기서 함수는 2번 호출되고 2개의 다른 상수 지역변수가 사용된다.

- 변수
변수 선언 var는 특정 타입을 가진 새 변수를 만든다. 이름을 붙이고 초기값을 설정한다.
기본적으로 해당 형식을 가진다.
var name type = expression

타입 또는 = expression 파트는 아마 빠뜨렸ㅆ을것이다. 하지만 둘 다는 안된다.
타입이 배제되면 expression에 의해서 결졍된다.
expression이 배제되면 초기값은 각 타입의 zero value이다.
bool의 경우 false, 숫자의 경우 0, string의 경우 "", 인터페이스나 참조(slice, 포인터, map 채널, 함수)의 경우 nil이다.
총계하는 타입 ex)array, 구조체 의 경우 zero value는 각 원소, 필드의 zero value이다.
zero value메커니즘은 변수가 항상 각 타입의 잘 정의된 값을 가지도록 만든다.
go언어에서는 초기화되지않은 변수란 없다.
이것은 코드를 단순화시키고 추가적인 작업 없이 합리적인 행동을 보장한다.
예시코드()
빈 string을 출력하는것이 에러를 유발하거나 예상치못한 행동을 하는것이 더 좋다.
또한 하나의 선언에서 여러개의 변수를 초기화 할 수 있다.
(예시코드)
bool:                    %t
int, int8 etc.:          %d
uint, uint8 etc.:        %d, %#x if printed with %#v
float32, complex64, etc: %g
string:                  %s
chan:                    %p
pointer:                 %p

2.3.1 짧은 변수 선언 ( 변수 선언하는 또다른 방법 )
short variable declaration 연산자 := 는 golang에서 변수에 적절한 값, 이름을 지정하기 위해 사용한다.
이 연산자는 간결성과 유연성을 지니므로 주로 함수 내부의 로컬 변수를 선언, 초기화하고 변수의 범위를 좁히는것이 주 목적으로 사용된다.
간결성을 지니는 이유는 var처럼 타입을 명시적으로 나타내지않고, 변수에 값을 나중에 할당하고 초기 값이 중요하지 않은경우 사용한다. 즉, 변수선언을 우선하고 값에의해 타입이 결정된 후 할당된다.
var 변수 선언과 다르게 := 변수의 타입은 표현에 의해서 결졍된다.
주의점은 var 키워드는 함수 내부, 외부에서 모두 사용가능하지만 := 연산자 선언은 함수 내부같은 지역변수를 선언할 때만 사용할 수있단것이다.
또한 여러개의 변수 선언과 같은 가독성을 높이기 위할때 사용하는것이 좋다.
짧은변수선언은 필수적으로 선언의 기능을 하진않는다.
만약 변수 중 하나가 관찰 가능한 범위 내에서 이미 선언되었다면 짧은변수 선언은 할당처럼 동작한다.
그리고 짧은 변수 선언은 재정의 시 오류 발생.
적어도 하나 이상의 새로운 선언이 필요하다
es, err := 1, 3	es, err := 1, 3
os, err := 1, 4	es, err := 1, 3 // error

var, short 다른점
1. var는 go언어에서 제공하는 문법적 키워드이다. / :=는 short declaration 'operator' 즉 연산자이다.
2. 함수 내,외 적으로 변수를 선언 ,초기화시 사용한다, / 오직 함수 내부에서만 선언이 가능하다.
3. 사용할 시 변수는 보통 패키지레벨 또는 글로벌 레벨 범위를 가진다. 또한 지역범위로도 사용이가능하다
/ 지역단위로의 범위만 가질 수 있고, 함수 내부에서만 선언된다.
4. 선언과 초기화를 따로할 수 있다. / 선언과 초기화가 동시에 이뤄진다.
5. 타입을 추가적으로 추가해줘야한다. / 타입을 입력할 필요가 없다.

2.3.2 포인터

변수란 값을 포함하는 저장소의 조각이다.
선언을 통해 생성된 변수는 이름에 의해 식별된다. ex) var x 등..
하지만 많은 변수는 표현에 의해 식별된다.  x[i]나 x.f등..
이러한 모든 표현은 변수의 값을 읽는다. 그들이 좌측 할당에서 나타날때를 제외하고.
이러한 경우는 새로운 값을 변수에 할당하는것이다.

포인터의 값은 변수의 주소이다.
그러므로 포인터란 값이 저장된 위치란 뜻이다.
포인터가 있다면 우리는 변수의 값을 즉시 읽거나 수정이 가능하다.

var x int라고 선언된 변수가 있다면 &x("address of x")라는 표현은 정수변수에 대한 포인터이다.
즉, *int 타입의 값이란 뜻이고 pointer to int 이므로 &x는 point to x 이 된다.
만약 x 가 p에의해 지목되면
p points to x이고 p는 x의 주소를 가진다 라고도 해석이 가능하다.
또한 배열같이 어떠한 타입을 묶어놓은 타입 또한 각 원소가 주소를 지닌다.
또한 포인터의 zero value는 nil이다.
또한 포인터끼리 비교할 시 같은 변수를 지목하면 같은 포인터이다.
이것은 함수에게 완벽히 안전하다 지역변수의 주소를 리턴할 때
예를들어 밑 코드에서  특정 함수호출 f에 의해서 v가 만들어지는데 v는 호출이 종료되어도 남아있다.
* 나중에 더..포인터는 flag 패키지의 키 포인트다.
커맨드 라인 인자에 특정 값을 프로그램을 통해 변수에 뿌린다.
실현을위해 

2.3.3 new function

변수 생성하는 방법임. built-in 함수인 new 함수 사용하는것
new(t)의 표현은 이름이 정해지지않은 타입 t 의 변수를 만든다. t의 zero value로 초기화된다.
그리고 주소를 리턴한다. 따라서 값의 타입은 *t이다.
"주로 구조체와 함께 사용할 때 유용하다"
func new(Type) *type
ex) p := new(int) p는 *int형 포인터변수이다.
new 함수를 이용하거나 var를 이용하거나 차이점이 없지만, new함수를 이용한 경우 명명하지 않아도 된다는 점이 있다. 왜 이게 편하냐면
예를들어 자료구조에서의 연결리스트를 만들 때 처음에 초기화를 할때 getnode()함수를 사용할 수 있는데 이 때 간편히 사용할 수 있다.

func getNode *node {
	return new(node)
}

또한 new 함수로 만들어진 포인터는 고유한 주소를 가진다.
p := new(int)
q := new(int)
fmt.Println(p == q) // false
룰의 하나의 예외가 있는데
유형이 정보를 전달하지 않고 따라서 크기가 0인 두 변수
struct {}나 [0]int 같은 경우 실행할 경우에 따르고 같은 주소를 가진다.

new함수는 상대적으로 드문드문 사용된다 왜냐하면 구조체 타입의 흔한 비작명 변수는 struct 리터럴 syntax가 더 유용하기때문

new 함수는 keyword가 아니므로 이름 재정의가능 
func delta(old, new int) int {return new - old}

2.3.4 변수의 생애주기
변수의 생애주기는 시간사이의 간격이다 프로그램이 실행되는 동안의
패키지레벨의 변수의 생애주기는 프로그램 전체의 실행시간동안이다.
대조적으로 지역변수는 동적인 생애주기를가진다.
새로운 인스턴스가 만들어지고 선언문이 실행될때, 변수는 살아있다 unreachable까지, 그시점 저장소는 재사용된다.
함수 매개변수와 결과 또한 지역변수와 같다. 함수가 호출될때부터 종료될때까지이다.

가비지콜렉터는 어케알고 수집하노?
기본 아이디어는 현재 활성화된 패키지레벨 변수 그리고 함수에서 활성화된 모든 지역변수는
잠재적으로 해당 변수에 대한 경로의 시작 또는 루트일 수 있다.
따라오는 포인터, 다른 종류의 참조는 궁극적으로 변수에게 이끈다.
만약 그러한 경로가 없다면 변수는 unreachable이 되고 이것은 더이상  남은 연산에 영향을 끼치지 못한다.

왜냐면 변수의 생애주기는 도달가능여부에 달려있기 때문이다.
지역변수는 생애주기가 연장된다 근처의 loop의 단독 반복에서
이것은 존재를 지속시키고 인접 함수가 닫힌후에도 지속된다.
컴파일러는 아마 고르려고 할것이다.. 할당한 지역변수 힙위의 또는 스택 하지만 아마도 놀랍게도
이 선택은 var 또는 new 에의해 선언될 때 결정되지않는다.
var global *int
func f() {			func g() {
	var x int			y := new(int)
	x = 1				*y = 1
	global = &x	}	
}
여기서 x는 힙에 할당되어야한다. 왜냐면 global변수에의해 f가 리턴된이후에도 관찰가능하기때문
우린 이것을 x가 excape from f 라고한다.
대조적으로 g는 리턴되면 변수 *y는 관찰되지못하고 재활용된다.
*y가 g에서 탈출하지 못했으므로 컴파일러는 *y를 스택에 할당하는것이 안전하다. new로 할당되었음에도 불구하고말이다.

어떠한 경우에도 escape의 개념은 코드작성 시 신경쓸 문제가 아니다.
그래도 항상 프로그램의 최적화 퍼포먼스를 위해서 기억해두는것이 좋다.
escape 작업시 추가적인 메모리 할당이 필요하기 때문이다.

쓰레기 수집은 좋은 프로그램을 작성하기 위해 엄청나게 도움이 된다.
하지만 당신이 메모리를 신경쓰지 않게 만든는것은 아니다.
당신이 명시적으로 메모리를 free해주지않아도 되지만 효율적인 프로그램을 위해 변수의 생애주기를 항상 염두에둬야한다.
예를들어 장수하는 물체, 특히 글로벌한 '변수' 안에 단명하는 물체에 대한 불필요한 포인터를 보관하는 것은 쓰레기 수집가가 단명된 객체를 수거하는것을 막을것이다.

2.4 할당
변수에 의해 잡힌 값은 할당문에 의해 갱신된다.
간단한 형태를 가진다 변수 = 표현
variable = expression

2.4.1 tuple 할당
할당의 다른형태, tuple 할당 허용한다. 다양한 변수를 한번에 할당하는것을
모든 오른쪽 표현은 평가된다 변수가 갱신되기 전에
이 형태를 가장 효율적으로 만드는것은 양 쪽에 변수가 할당되었을때이다. 예를들어 두 변수를 바꾸는 함수를 작성하려면?
x, y = y, x
튜플 할당 시 = 연산자 기준으로 오른쪽 표현부터 평가된다.
그 후 좌항에서 오른쪽 표현부터 순서에 맞게 할당된다.
예를들어 x, y = y, x+y 라는 구문이 있다고한다면
y에 x+y가 할당되고 x에 y의 값이 할당된다.

또한 튜플 할당은 blank identifier 와 함께 쓸 수 있다.
blank identifier는 선언되었지만 사용되지않아도 되는 변수를 말한다.
주로 2개이상의 리턴타입을 가지는 함수에서 값을 리턴받을 때 어떤 값을 사용하기 원치않을 때 사용한다.
공백 식별자는 값으로 사용할 수 없고 주소도 가지지 않는다.
또한 공백 식별자는 한 범위 내에서 여러번 선언할 수 있다.


2.5 타입선언
변수나 표현의 유형은 그것이 취할 수 있는 값의 특성을 정의한다.
그들의 사이즈나 내부적으로 어떻기 표현되는지, 그들이 사용할 수 있는 고유한 연산자, 연관된 메소드에 달렸다.
어떤 프로그램에서나 같은 묘사를 공유하지만 전혀 다른 컨셉을 지닌 변수가 있다.
예를들어 int는 loop의 index나 파일설명자나 달력의 달을 묘사할 수 있고
float64는 속도, m/s, 온도 등을 묘사할 수 있고
string은 비밀번호, 이름, 색깔 등을 묘사할 수 있다.

타입 선언은 go언어에 정의되어있는 타입과 이름만 다르고 근본적으로 같은 타입을 정의하는것이다.
작명된 타입은 다른 타입으로 제공되므로 go언어에 정의된 타입과 비교할 수 없다
.타입 선언은 종종 패키지레벨 에서 보인다.
만약 작명 시 이름의 첫글자가 대문자라면 패키지 밖에서도 접근이 가능하다.
import "fmt"
type Celsius float64
type Fahrenheit float64
const (
AbsoluteZeroC Celsius = -273.15
FreezingC Celsius = 0
BoilingC Celsius = 100
)
func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
패키지는 두개의 타입을 정의한다
두 타입모두 float64이지만 같은 타입은 아니다. 따라서 둘은 산술연산자로 비교하거나 합칠 수 없다
타입을 구분하는것은 에러를 막아주고 무심코 다른 스케일을 합치는것을 막는다.
예를들어 명시적인 타입변환 // 함수아님 ->Celsius(t)나 Fahrenheit(t)같은 경우에말이다.
이 경우 어떠한 경우에도 값이나 표현을 변경하지 않는다.
하지만 그들은 명시적인 의미를 변화시킨다. 즉, float64와 값이나 표현은 같지만 다른 표현인 Celcius로 바꿀 수 있다는 의미이다.
반면 CToF나 FToC는 두 스케일 간 변환을 한다.
두 함수는 다른 값을 리턴한다.

모든타입 t에 대해 비교가능한 연산 t(x)가 존재한다.
t(x)는 값x를 t타입으로 변환하는 연산자이다.
변환은 두 타입이 근본적으로 같은 타입일 경우 가능하다.
또는 두 타입모두 같은 근본타입을 가진 변수를 포인트하는 작명되지 않은 포인터인경우 가능하다.
이러한 변환은 타입을 변경하지만 표현된값을 바꾸진않는다.
x가 t에 할당가능할 변환은 허용되지만 대개 쓸모없는것들이다.
예를들어 t,x 모두 int16 타입인데 굳이 변환을 할 필요는 없다.

변환은 숫자(numeric type)사이에 가능하다.
그리고 스트링과 slice타입 사이에도 가능하ㅏㄷ.
이러한 변환은 값의 표현을 바꿀수 있다.
예를들어 부동소수점에서 정수로의 변환은 소수점부분을 버리고
스트링에서 []byte로의 변환은 스트링의 데이터 복사본을 슬라이스에 할당한다.
어떤경우던 변환은 런타임시 절대 실패치않는다.

작명된 타입의 기본 유형은 구 구조와 표현, 그리고 그것이 지원하는 내적 운영의 집합을 결정하는데 이는 기본 유형을 직접 사용한것과 같다.
예를들어 float64로 연산을하거나 Celcius 타입으로 연산을 하나 동일한 연산작업을 수행한다는 것이다.
ex) 위에서 Celcius 타입으로 설정된 
FreezingC, BoilingC 두 타입은 같기때문에 산술연산

named type은 표기법의 편리성때문에 사용된다.
이표기법은 복잡한 타입을 작성하는것을 피하게한다.
float64따위로 작은 타입과 동일하게 예시를 들어서 왜사용하는지 이해가힘들 수 있지만.
다른 복잡한 타입, 기계의 동작상태같은 구조체같은.. 그러한 타입이 사용될 시 유용케 사용할 
수 있다.

또한 타입의 값에 새로운 행동을 정의할 수 있다.
이러한 행동들은 표현된다. 함수의 무리에 의해 타입과 관련된,
타입 메소드라고 불리는(chap.6)


2.6 패키지와 파일
go 안의 패키지는 다른 언어의 라이브러리와 동일한 목적을 가진다.
모듈화, 캡슐화, 분리 컴파일, 재사용을 돕는다,
패키지를 위한 소스코드는 하나 이상의 go파일에 저장되어있다.
대개 import path한 한 디렉토리에 있다.

각 패키지는 분리된 네임스페이스에서 제공된다. 이것을위한 선언에
~파일에 저장되고
사용하려면 package 패키지이름으로 저장
사용시 import 해주고 패키지이름.사용원하는 타입이름 등으로 사용하자.

2.6.1 imports
go에선 모든 패키지가 import path라고 불리는 고유한 스트링으로 구별된다.
이러한 스트링들은 import선언에서 나타난다.
ex) "gop1.io/ch2/tempconv" 같은..
언어는 이 스트링이 어디서왔는지, 무엇을 의미하는지 정의하지는않는다.
그것을 해석하는 툴에 달려있는것이다.
go tool(chap.10)사용 시 import path는 나타낸다.
디렉토리가 하나이상의 go소스파일을 포함한다는것을 패키지파일로 같이 만들어진,
https://thenewstack.io/understanding-golang-packages/


2.7 scope범위

선언은 연관짓는다. 이름ㅇ,ㄹ 프로그램 개체와 함께 함수나 변수처럼.
선언의 범위는 선언된 이름을 사용하는 것이 해당 선언을 가리키는 소스 코드의 부분이다.
범위를 생애주기와 혼동하면 안된다.
선언의 범위는 프로그램 텍스트의 지역이다.
이것은 컴파일타임 우선이다.
변수의 생애주기는 시간의 범위이다. 실행되는동안의,
만약 변수가 참조가능할때 다른 프로그램의 부분에서, 이것은 런타임 우선이다.
구문적인 블록은 문의 순서이다. 중괄호로 닫힌, 함수나 루프의 몸체와 같이.
구문블록안에 선언된 이름은 블록밖에선볼수없다.
블록은 그 선언문을 동봉하고 그 범위를 결정한다.
우리는 생성한다. 블록


go 특징
1. 정적타입, 강타입
정적 타이핑은 프로그램 실행 전 옳은가를 체크함
이작업은 주로 언어의 컴파일러가 수행한다. 자바..

동적 타이핑은
프로그램 실행중에만 타입을 알 수 있음. 파이썬..
def erroneous():
    s = 'cat' - 1

print('hi!')
해당코드 오류 x 하지만 erroneous 호출 시 오류발생

2. 컴파일언어
컴파일 = 소스코드에서 목적코드로옮기는 작업
과정
1) 소스파일을 바이너리파일로 번역
2) 실행 후 cpu에서 ram으로 로드
3) 결과출력
c++, java, go 등..

cpu가 알아들을 수 있는 기계어로 번역하는것임. 바이너리파일이라고도불림

인터프리터는 소스코드 가 컴파일러아닌 인터프리터에게 직접 번역, 실행동시에함
실행파일 존재하지않음, os에서 ram에 로드되어 cpu에서 실행
소스코드 한줄한줄읽으며 실행
jsp, 파이썬, sql등..

컴파일장점 : 컴파일 완료한 실행파일 존재하므로 인터프리터로 실행하는것보다 빠르게 동작
인터프리터 장점 : 컴파일x 별도의 컴파일시간 x
큰 소스코드에도 컴파일시간들지않아 바로실행가능

강타입은 타입체크의 강도에 따라 구분함
약타입은 int, float 더할시 암묵적형변환 허용치만
go언어는 int, float더할 시 컴파일 에러가 발생한다.

3. 가비지콜렉션
정의 : 사용되지 않는 메모리 공간을 free해주는것
즉, 범위 밖의 객체나 더이상 참조불가능한 객체의 메모리공간을 free하여 소비가능케만드는작업
이 작업은 프로그램 실행되는 동안 동시에 수행
바둑 가비지 수집기의 주요 관심사는 대기 시간이 짧다는 것인데, 이는 기본적으로 실시간 작업을 하기 위해 가동을 중단하는데도 금방 작업을 시작하기때문이다.
그럼 어떻게 이런 짧은 대기시간을가지는가?

한편, 프로그램이 하는 일은 항상 포인터를 사용하여 새로운 개체를 만들고 기존 개체를 조작하는 것이다.
이 프로세스는 이러한 개체를 가리키는 포인터가 없기 때문에 더 이상 액세스할 수 없는 개체를 생성하게 될 수 있다.
이 물건들은 쓰레기가 되고 쓰레기 수거업자가 그것들을 청소하고 그들의 기억 공간을 자유롭게 할 때까지 기다린다.
그 후 자유로워진 기억 공간은 다시 사용할 준비가 되어 있다.

- concurrent 마크앤스윕 알고리즘 사용
우선 각 Algorithm을 살펴보기에 앞서 어떤 Object를 Garbage로 볼 것이냐에 대한 이해가 글을 읽는 데 도움이 될 것이다. Garbage Collector는 객체를 Reachable과 Unreachable의 상태로 구분한다. 구분하는 방법은 Root set 과의 관계로 판단한다. Root Set으로부터 어떤 식으로든 Reference 관계가 있다면 Reachable Object라고 판단하고 Root Set으로부터 참조하는 Reference 관계가 없다면 Unreachable Object라고 판단한다. Root Set을 간단하게 설명하면 객체들 간에 참조 사슬의 시작점이라고 보면 된다.

cms gc 설명
mark단계에서 참조되지않는 자료 마크
councurrent mark 단계에서 한번더 확인
sweep 단계에서 가비지콜렉션 수행

- 초기 가비지콜렉션 알고리즘
Reference Counting Algorithm
Garbage의 Detection에 초점이 맞추어진 초기 Algorithm이다. 각 Object마다 Reference Count를 관리하여 Reference Count가 0이 되면 GC를 수행한다.
위 그림에서 a와 b는 각각 100, 99의 값을 갖는 Integer Object로 선언되어 있다. 각 Integer Object는 Referece Count가 1로 설정되어 있다. 이 상태에서 b = a로 변경하게 되면 a가 참조하고 있던 100의 값을 갖는 Integer Object는 참조가 없어지기 때문에 Reference Count가 0으로 감소하게 되고 GC가 수행된다.
이 방식은 Reference Count가 0이 될 때마다 GC가 발생하기 때문에 Pause Time이 분산되어 실시간 작업에도 거의 영향을 주지 않고 즉시 메모리에서 해제된다는 장점이 있으나 각 Object마다 Reference Count를 변경해 주어야 하고 참조를 많이 하고 있는 Object의 Reference Count가 0이 될 경우 연쇄적으로 GC가 발생할 수 있는 문제가 있고 Reference Count의 관리 비용도 크다. 또한 Linked List와 같은 순환 참조 구조에서 Memory Leak이 발생할 가능성도 크다.

3. 동시성(concurrency), 병렬성(paralㅣelism)

goroutine은 concurrency를 위해 go runtime에서 직접 관리하는 lightweight 스레드입니다.
고루틴은 go 가상머신 위에서 수행되는 스레드이다.
고루틴은 다른 go 루틴 존재하지 않을 시 main goroutine에서만 실행되고
다른 go루틴 실행 시 동시에 같이 실행된다.

먼저 concurrency부터 이야기하면, 어떤 프로그램이나 알고리즘이 순서에 상관없이 동시에 수행될 수 있다면 concurrent하다고 말합니다.  예를 들어, 1부터 100까지 숫자를 더하는 과정을 생각해보면 숫자 100개를 여러 부분 집합으로 나눈 뒤 동시에 부분합을 구합니다. 그리고 이 부분합을 다시 더하면 원래 얻고자 하는 값을 얻을 수 있습니다. 이 때 이 알고리즘은 concurrent하다라고 말합니다.



그런데 이 알고리즘이 정말 물리적으로 병렬로 돌아갈지 아닐지는 이 알고리즘이 어떤 하드웨어 위에서 돌아갈지 알아야만 확답할 수 있습니다. 방금 이야기한 알고리즘이 멀티 프로세서 머신에서 돌아가야 병렬 실행된다라고 말할 수 있습니다. Parallel execution은 따라서 프로그램의 성질보다는 하드웨어의 성질입니다.



Concurrent한 프로그램은 싱글코어 머신에서도 분명히 돌아갑니다. 뮤텍스, 데드락은 싱글코어에서도 얼마든지 그 의미를 갖습니다. 멀티스레드 프로그램이 비록 물리적인 제약으로 싱글코어에서 시분할 형태로 돌아가지만 겉으로는 concurrent하게 작동한다고 속일 수 있습니다. 반대로 아무리 멀티스레드로 작성된 프로그램이라 하더라도 멀티코어가 아니라면 병렬로 작동한다고 말하지 못합니다.



OpenMP, MPI, CUDA 같은 프로그래밍 방법론은 병행 프로그래밍 보다는 병렬 프로그래밍이 옳은 표현합니다. 언급한 세 방법론 모두 물리적으로 제공되는 다양한 병렬 하드웨어를 활용하기 때문입니다.



멀티 스레드 프로그램에서 벌어지는 각종 버그를 concurrency bug라고 부르는데, 굳이 하드웨어가 반드시 병렬성을 지원하지 않더라도 논리적으로 발생하니까 concurrency라는 말이 옳습니다.



보통 프로그램에서 병렬성을 찾는다고 하지 병행성을 찾는다고는 말하지 않습니다. 약간 모호하기는 하나 결국 물리적으로 병렬 실행이 가능한 코드를 찾는 것이니 병렬성이 더 합리적으로 보입니다. 어떤 함수에 락을 무식하게 크게 걸면 병행성(concurrency)가 나빠진다고 말합니다. 병렬성이 나빠진다고는 말하지 않습니다.



프로세스(process)란?
프로세스(process)란 단순히 실행 중인 프로그램(program)이라고 할 수 있습니다.

즉, 사용자가 작성한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것을 말합니다.

이러한 프로세스는 프로그램에 사용되는 데이터와 메모리 등의 자원 그리고 스레드로 구성됩니다.

스레드(thread)란?
스레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미하고 프로세스의 실행단위입니다.

모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행합니다.
프로세스와 같이 실행, 준비, 대기 등의 실행 상태를 가지며
실행 상태가 변할때마다 쓰레드 문맥교환(context switching)을 수행한다.
각 쓰레드별로 자신만의 스택과 레지스터를 가진다.

프로세스 - 레지스터, 메모리(힙, 스태틱, 코드, 스택), 쓰레드(레지스터, 스택)N개... -> 여기서 쓰레드가 가지는 스택은 프로세스가 os에게 할당받는 메모리 내의 스택을 관리하는것.


또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process)라고 합니다.

프로세스는 os로부터 메모리, io장치를 할당받고 쓰레드는 프로세스가 할당받은 메모리, io장치를 공유하며 일을한다.
여기서 일을할 때 com자원 최대활용위해 병렬적으로 일하게 만들어야하는데
해당 영역을 멀티 쓰레드 프로그래밍의 영역이다.
언어에서 병렬성이라고 불리는 대표예가 쓰레드이다. 따라서 쓰레드는 기계기반적인 단어라고 할 수 있다

4. 모듈화
코드 재사용 및 코드 유지보수성 향상을 위해서 모듈을 사용하는것
모듈이란 독립적으로 재활용될 수 있는 소프트웨어 덩어리를 말한다
하나의 모듈은 자신을 사용하기 위한API제공하며, 자신이 포팅되기 위한 명확한 환경 나열할 수 있어야함.

5. 컴파일속도 향상
Go 언어는 C, C++과는 달리 헤더 파일이 없고, 소스 코드를 패키지화하여 변경된 부분만 컴파일하므로 컴파일 속도가 빠릅니다.
 또한, 문법적으로도 복잡한 요소를 최대한 줄여 컴파일 속도에 유리하게 설계했습니다.

2) go 시작하기
중괄호, 들여쓰기 ,세미콜론, 주석 ,gofmt ( go 소스코드를 출력하는것 ) 

3) 타입
실수 ,복소수 , 정수, 바이트 ,룬 ,


실수표기 1.3e+10 = 1.3 x 10^10 (-의경우 10^-n)
12.345E+3 = 12345.0
또한 실수의 경우 반올림해서 10.0 같은 값이 존재 실제로는 .0000000000000004 같이 부정확
따라서 math 를 import 하여서 abs 함수 사용해서 비교해야함
또한 %연산 불가.
실수 / 실수 = 실수




정수표기 
10, -1, 073(8진), 0x104(16진)
쉬프트 연산또한 가능한데 << 나 >>으로 표기 쉬프트한 값만큼 2^n의 연산
<<일시 곱연산 >>일시 나눗셈 ^은 비트반전연산자
또한 uint32 -> uint16으로 타입변환시 넘치는값 버린다.
ex) var a uint8 = 128
    var b uint32 = 80000
a - uint16(b) = 128 - 2^16
음수 %연산시 나머지또한 음수.
정수 / 정수 = 정수
또한 int 는 운영체제에 따라서 다르다 32비트 = int32, 64bit = int64
int는 2의보수형태를 띈다.
int는 덧셈 시오버플로우시 최상위 비트인 부호비트가 1로바뀌면서 음수표현
uint는 덧셈 시 오버플로우 시 0부터 다시시작
int는 곱셈 시 덧셈처럼 곱한 수 만큼 음수표현 ( -1 부터 )
uint 또한 곱셈 시 덧셈처럼 곱한 수 만큼 양수표현 ( 0부터 )

바이트 uint8 크기 but 서로 변경은 불가
16진수, 문자값 주로저장 바이너리파일에서 데이터 읽고 쓰거나 암호 암,복호화시 사용

룬 int32 크기
utf저장시 사용
작은따옴표안에 그대로 문자적거나, '\uaa' 또는 '\U000000aa'같이 표기
소문자는 우항부터 채우기, 대문자는 16진수 8문자로 맞춰야함

비교연산 시 부울, 숫자, 스트링 모두 같은타입끼리는 비교가능 so ==, != 연산자 등.. 사용가능
다른타입끼리는 비교x int8, int32 같이..

타입 곱셈 출력할 때
uint8의 최대값 255 + 1 한다면? 100000000이 되고 8비트까지 출력이 되므로 0 출력
255 * 2 한다면? 510이 되고 111111110이 되며 8비트까지 출력하므로 254가 출력된다.
int8 최대값 127 + 1한다면? 부호비트가 바뀌고 -127이 된다.
127 * 2 한다면? 01111111이고 254는 11111110이 된다. 따라서 -2가되는데 질문올렸다.

정수 정리
정수엔 2가지 종류 존재한다.
int, uint 그중에서도 4개씩 나뉘는데 8, 16, 32, 64비트로 나뉜다. 물론각 타입 사이즈 다르고 서로 다른타입으로 취급해 연산불가 비트언급하지않을 시 하드웨어에따름.
룬은 unicode 표현위한 32비트 int형이지만 두 타입은 비교불가하다.
하지만 형변환을 해주면 연산가능.
마지막으로 uintptr 존재한다. 포인터 값을 가지는 타입인데, 실제로 포인터를 저장하는게아니라 주소를 직접저장하기때문에 보안적으로 좋지않다.
signed 정수는 2의보수 형태를 띈다. 최상위비트에는 부호비트가있고, 범위는 2^n-1 ~ 2^n-1 - 1 까지이다.
int8의 범위는 -128 ~ 127 까지이다.
정수에 적용 가능한 연산자 종류는 다음과 같다.
5* / % << >> & &^
4+-|^
3== != < <= > >=
2&&
1||
앞의 숫자는 연산자 우선순위이며 숫자가 높을수록 먼저 계산한다.
우선순위가 같은 연산자가 존재할 경우 좌->우로 연산한다. 또는 연산자 순위를 정해주기 위해선 괄호로 묶을 수 있다.
해당 연산 중 %는 부동소수점에만 적용가능
go언어에선 다른 언어와 다르게 음수에 나머지 연산% 적용할 시 나머지가 음수로 나온다.
연산자의 행동은 피연산자가 무슨 타입인가에 달렸다.
5 / 4는 1이지만 5.0 / 4.0 은 1.25이다.
정수 나눗셈은 소수점 이하 자리들은 0으로 바꾸기 때문이다
산술 연산의 결과로 signed든 unsigned이든 해당 타입에서 표현할 수 있는 비트보다 더 많은 bit를 가질 경우, overflow라고 부른다.
맞지않는 고차비트는 버려진다. 만약 원래의 값이 signed 타입이라면 부호비트가 1로 바뀌면서 결과는 음수로 변할 수 있다. 
예시
var a uint8 = 255
var b int8 = 127
fmt.Println(a * 2)	// 254 		255 * 2 = 510 binary 11111110 최상위비트 1 버리고 11111110 즉 254
fmt.Println(b * 2)	// -2 binary 11111110 부호비트 1이므로 2의보수 연산 10000010 
fmt.Println(b * 3)	// 125 binary 101111101 부호비트 포함 01111101 양수이므로 1111101 = 125
fmt.Println(b + 1)	// -128 2진법 01111111 + 1 = 10000000 부호비트 1으로 바뀌고 8비트이므로 값 버리지 않음.

두 정수타입이 같을 시 이진비교연산자를 사용해 비교가 가능하다.


정수 비교연산
==, !=, < <=, >, >=

단항연산 +, -
정수의 경우, +x는 0+x의 속기, -x 는 0-x의 속기
부동소수점의 경우 +x, -x 는 그저 x와 x의 부정(not)이다.

비트연산
&, |, ^(XOR), &^, << , >>
이들 중 처음 4명은 산술 운반이나 부호의 개념이 없는 비트 패턴으로 처리한다.
^는 두 피연산자의 연산자가 아닌 단항에 접두사로 들어갈경우 부정not 의 연산을 한다.
IE. &^ = AND NOT

쉬프트 연산
쉬프트 연산은 x << n, x >> n 같은 형태로 사용한다.
x는 int, uint 상관없지만, n은 이동할 비트 위치의 수를 결정하며 uint 타입이어야한다.
uint의 경우 좌쉬프트연산은 0으로된 비트를 1로 채운다. 우측연산 또한 같은 동작을한다.
int의 경우 우측쉬프트 연산은 빈 비트를 부호 비트의 복사본으로 채운다.
이러한 이유로 비트 패턴을 다룰때는 uint를 사용해야 한다.

음수 int의 우측쉬프트가 항상 -1인이유:
우측 쉬프트연산자는 나눗셈을 하지 않음.
 그들은 그들이 해야 할 일을 한다. 즉, 비트를 바꾼다. 특히 우측 시프트 운영자는 다음과 같이 한다.
1.오른쪽에서 시작하는 각 비트에 대해 해당 값을 왼쪽에 있는 값으로 설정하십시오.
2.왼쪽에 아무것도 없는 가장 왼쪽 비트는 현재 가치를 유지한다.

만약 110....101 우측쉬프트? -> 111...10
SO 최하위 비트는 소실되고 최상위 비트의 복사본으로 채워진다.
이 현상은 신호 전파(sign prepagation)라고 불린다.
왜냐면 음수인 정수에선 최상위 비트가 부호비트라고 불리는 비트로 채워져 양수인지 음수인지 구별하기 때문이다.

음수는 2의 보수로 저장된다. 32비트 운영체제에서 -x는 2^32 - x 로 저장된다.
이것은 1000....000(32개의 0)에서 1을 빼는것과 동일하기 때문에 111....111(32개의 1)으로 저장된다.
따라서 음수인 정수에서 우측 쉬프트연산을 아무리 하더라도 -1인 이유이다.
또한 이것은 비트패턴을 다룰 때 uint 산술타입을 사용해야하는 이유이다.

ie. var a int8 = -8	
-8 = 10001000 = 11110111 = 11111000 >> 1 = 11111100 >> 1 = 11111110 >> 1 = 11111111
			
오른쪽 시프트와 나누기 2의 차이는 시프트가 홀수 및 짝수에 대해 동일한 결과를 준다는 것이다.
나누기의 경우 3 / 2 = 1 4 / 2 =  2 이지만
그래도 나눗셈의 관점에서 보고싶다면 %연산자로 생각시 편하다
https://stackoverflow.com/questions/26821728/why-does-right-shifting-1-always-gives-1-in-php

비록 go에서 제공하는 uint가 숫자와 산술에 사용될 수 있지만 의도적으로 int형을 사용해야할때가 있다.
예를들면 음수로 넘어가지 않는 조건을 가진 배열의 범위같은..
그렇기 때문에 built-in 함수인 len()함수 사용시 리턴값은 int형이다.
medals := []string{"gold", "silver", "bronze"}
for i := len(medals) - 1; i >= 0; i-- {
fmt.Println(medals[i]) // "bronze", "silver", "gold"
}
만약 저 반복문에서 len이 uint형이라면 i가 0이 된 후 i-1을 하면 i의 최대값인(운영체제에 따라서 다르다.) 2^32 - 1이나 2^64 - 1이 나왔을것이다.
따라서 배열(slice)범위 밖의 원소를 참조하려 했으므로 컴파일 시 오류가 발생하게된다.
이 때문에 uint는 비트패턴을 다루는 연산이나 특정 연산시 사용한다.

모든타입 T에 대해서 허용가능한 범위에서 변환(convert)연산 T(x)는 값 x를 타입 T로 변환시킨다.
대부분의 정수간 타입변환 연산에서 값손실은 일어나지 않지만 타입 T보다 큰값이 x에 들어올 시 넘치는 값은 버려진다.
또한 부동소수점 타입에서 정수간의 변환에서도 소수점아래의 값은 버려진다.
f := 3.141 // a float64
i := int(f)
fmt.Println(f, i) // "3.141 3"
f=1.99
fmt.Println(int(f)) // "1"

어떤 사이즈 타입의 정수라도 8진수로 표현할 수 있다.
표현방법은 선언이나 할당 시 맨앞에 0을 붙여주면된다. IE) 0666, 0764..
또한 16진수로도 표현이 가능하다 맨앞에 0x를 붙이고 작성한다. IE) 0xdeadbeef, 0x1234567
대문자나 소문자나 같은 값을 표현하므로 따로 구분짓지않아도 된다.
최근에는 8진수는 특별한 목적을 위해서 주로 사용된다. IE) posix시스템..
%d, %o, and %x verbs, as shown in this example:
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
// Output:
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF

마지막으로 룬타입은 유니코드의 표현에서 주로 쓰이거나 단문 인용구 ' '사이에 넣어서 문자를 표현할 때 쓰는 정수타입이다.
ascii := 'a'
unicode := 'D'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii) // "97 a 'a'"
fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 D 'D'"
fmt.Printf("%d %[1]q\n", newline) // "10 '\n'"


3.2 부동소수점
go는 2개의 소수제공 float32, 64 
그들의 수학적 특성은 현대의 모든 CPU에 사용되는 IEEE754 표준에서 받아온것.
IEEE 754는 전기 전자 기술자 협회(IEEE)에서 개발한 컴퓨터에서 부동소수점을 표현하는 가장 널리 쓰이는 표준이다.
 ±0 등의 수와 무한, NaN 등의 기호를 표시하는 법과 이러한 수에 대한 연산을 정의하고 있다. 

부동소수점의 한계는 math패키지에서 찾을 수 있다.
math.MaxFloat64,32에서 찾을수 있다.
f32에서 6자리ㅜㅅ자까지 근삿값을 낸다. 64의 경우 15자리까지.
주로 64가 선호되는데 32를 사용하면 정확히 나타낼 수 있는 최소의 정수는 크지않고
그렇게 되면 조심스레 다루지 않는다면, 빠르게 오류가 축적되기때문.

var f float32 = 1 << 24
f == f + 1 // true
왜이럴까?
이유는 다음과 같다
IEEE754에 따르면 32비트 부동소수점은
부호비트, 8비트의 지수(-127바이어스), 23비트의 지수를 가진다.
10진수 0.000123은 0.123e-3으로 표현되고 -3은 지수, .123을 가수라고 한다

부동소수점은 %g를 통해서 꽤나 정확하게 출력가능.
테이블안의 값이라면 %e(exponent) 또는 %f(no exponent)폼이 더 정확하다.
math패키지 내의 Exp함수를 통해서 출력해보자



for x := 0; x < 8; x++ { 	
fmt.Printf("x = %d eA = %8.3f\n", x, math.Exp(float64(x)))	// %8.3f로 오른쪽 8개 숫자까지 깔끔하게 맞춤.

x=0 eA = 1.000
x=1 eA = 2.718
x=2 eA = 7.389
x=3 eA = 20.086
x=4 eA = 54.598
x=5 eA = 148.413
x=6 eA = 403.429
x=7 eA = 1096.633

math 패키지 사용시 다양하고 유용한 수학적 기능 사용가능. IEEE754에 정의된 특이한 값을 탐지할 수 있는데
그 예시로 NAN, INF, -INF, 0, -0 존재
var z float64
fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
nan := math.NaN() 사용해 비교연산자 사용해 nan 판단또한 가능.

3.3 부울린타입
2가지 값만 가질 수 있는 타입이다. t/f
if나 for문에서 조건문에서 사용한다.
==나 < 같은 비교연산자에서도 사용한다.
단항 연산자인 !은 부정의 의미다
(!true == false) == true는 true이다.
우리는 if문이나 for문에서 x == true를 x로 줄여서 작성할 수 있다.
부울형식은 &&, ||와 결합가능하며 &&은 ||보다 우선순위를 가진다. &&은 부울 곱셈연산이기때문.
또한 bool -> int형변환 불가능

