https://www.udemy.com/course/learn-go-the-complete-bootcamp-course-golang/?referralCode=5CE6EB34E2B1EF4A7D37

go는 다른언어처럼 여러개의 기본적인 구조가 모여 큰 프로그램을 빌드하고 변수는 값을 저장한다. 
이번챕터에선 기본구조 원소 go 언어 알아봄

go 함수, 변수, 상수, 타입, 문, 패키지의 이름은 간단한 룰을 따른다.
시작은 문자, 언더바로 시작하고 그 뒤에 아무숫자나 문자가 따른다.

go에는 25가지 키워드가 존재한다. (사진)
이 키워드는 변수나 상수의 이름으로 사용할 수 없다.
또한 int 나 true처럼 빌트인타입, 함수 등이 존재한다. (사진)
해당 이름들은 예약되지 않았으므로 선언시 사용이 가능하다.
만약 개체가 함수에안에서 선언되었으면 그 개체는 함수에 지역적이다.
만약 함수 밖에서 선언되었다면 해당 패키지를 가지 모든파일에 종속적이다.
이름의 첫번째 문자는 패키지의 경계에서 가시성을 결졍한다.	
만약 이름이 대문자로 시작하는 경우 이것은 외부적이다.
이것은 가시적이고 접근가능하단것을 뜻한다. 우리의 패키지의 밖에서 그리고 다른 프로그램의 파트에서도 참조 가능하다.
ex) Printf는 fmt패키지에속한다.
또한 외부에서 참조되는 함수는 대문자로 시작한다. ex)Printf는 fmt패키지 내부에 정의됨.
또한 줄임말보다는 의미가 명확하게 변수를 작명하는게 좋음
ex) for루프 시 i보다는 theLoopIndex처럼..

언어 스타일적으로 go언어는 2음절 이상의 단어에 낙타체를 사용한다.
음절사이에 언더바 보다는 대문자로 구분하는것을 선호한단뜻이다.
그러모르 스탠다드 라이브러리는 QuoteRuneToASCII나 parseRequestLine 같이 작명된 함수를 가진다.
여기서 HTML이나 ASCII는 항상 대문자로 사용해야하는 단어이다.
ex) HTMLEscape, escapeHTML

- 선언
선언은 프로그램 엔티티를 명명하고 그 속성의 일부 또는 전체를 명시한다.
선언에는 네가지 주 선언이 존재한다.

go에는 25가지 키워드가 존재한다. (사진)
이 키워드는 변수나 상수의 이름으로 사용할 수 없다.
또한 int 나 true처럼 빌트인타입, 함수 등이 존재한다. (사진)
해당 이름들은 예약되지 않았으므로 선언시 사용이 가능하다.
또한 외부에서 참조되는 함수는 대문자로 시작한다. ex)Printf는 fmt패키지 내부에 정의됨.
또한 줄임말보다는 의미가 명확하게 변수를 작명하는게 좋음
ex) for루프 시 i보다는 theLoopIndex처럼..

언어 스타일적으로 go언어는 2음절 이상의 단어에 낙타체를 사용한다.
음절사이에 언더바 보다는 대문자로 구분하는것을 선호한단뜻이다.
그러모르 스탠다드 라이브러리는 QuoteRuneToASCII나 parseRequestLine 같이 작명된 함수를 가진다.
여기서 HTML이나 ASCII는 항상 대문자로 사용해야하는 단어이다.
ex) HTMLEscape, escapeHTML

- 선언
선언은 프로그램 엔티티를 명명하고 그 속성의 일부 또는 전체를 명시한다.
선언에는 네가지 주 선언이 존재한다.
var, const, type, func
우린 여기서 변수 선언인 var를 살펴볼것이다.
go 프로그램은 .go 확장자로 하나 또는 그 이상의 파일로 저장된다.
각 파일은 파일의 일부라는것을 나타내는 패키지 선언으로 시작한다.
패키지 선언은 어떤 import 선언에 따른다. 그리고 타입, 변수, 상수, 함수 패키지레벨 순서의 선언에 따른다.
예를들어 해당 프로그램은 상수, 함수, 2개의 변수를 선언한다.
(예시코드)
상수 bolingF는 패키지 레벨 선언이다.
반면 c,f 변수는 main 함수의 지역변수이다.
패키지레벨 개체의 이름은 소스코드 뿐만 아니라 해당 패키지를 선언한 모든 go 파일의 범위에서 볼 수 있다.
대조적으로 지역내에서 선언된 c,f 변수의 범위는 main함수내이다.
함수선언은 이름, 매개변수 리스트(함수 호출자에 의해 정의된 변수들), 추가적인 결과의 리스트, 함수가 어떤 동작을 할지 정의한 문(statement)를 가진 함수몸체로 선언된다.
결과 리스트는 함수가 아무것도 리턴하지 않을 시 배제된다.
함수는 첫 문(statement)부터 리턴문 또는 함수의 마지막 부분을 만날때 까지 실행한다.
실행이 끝난 뒤 제어권, 결과는 함수 호출자에게로 넘어간다.
(예시)함수 fToC는 화씨 온도를 섭씨 온도로 변환하는 기능을 하는 캡슐화된 함수이다.
여기서 함수는 2번 호출되고 2개의 다른 상수 지역변수가 사용된다.

- 변수
변수 선언 var는 특정 타입을 가진 새 변수를 만든다. 이름을 붙이고 초기값을 설정한다.
기본적으로 해당 형식을 가진다.
var name type = expression

타입 또는 = expression 파트는 아마 빠뜨렸ㅆ을것이다. 하지만 둘 다는 안된다.
타입이 배제되면 expression에 의해서 결졍된다.
expression이 배제되면 초기값은 각 타입의 zero value이다.
bool의 경우 false, 숫자의 경우 0, string의 경우 "", 인터페이스나 참조(slice, 포인터, map 채널, 함수)의 경우 nil이다.
총계하는 타입 ex)array, 구조체 의 경우 zero value는 각 원소, 필드의 zero value이다.
zero value메커니즘은 변수가 항상 각 타입의 잘 정의된 값을 가지도록 만든다.
go언어에서는 초기화되지않은 변수란 없다.
이것은 코드를 단순화시키고 추가적인 작업 없이 합리적인 행동을 보장한다.
예시코드()
빈 string을 출력하는것이 에러를 유발하거나 예상치못한 행동을 하는것이 더 좋다.
또한 하나의 선언에서 여러개의 변수를 초기화 할 수 있다.
(예시코드)
bool:                    %t
int, int8 etc.:          %d
uint, uint8 etc.:        %d, %#x if printed with %#v
float32, complex64, etc: %g
string:                  %s
chan:                    %p
pointer:                 %p

2.3.1 짧은 변수 선언 ( 변수 선언하는 또다른 방법 )
short variable declaration 연산자 := 는 golang에서 변수에 적절한 값, 이름을 지정하기 위해 사용한다.
이 연산자는 간결성과 유연성을 지니므로 주로 함수 내부의 로컬 변수를 선언, 초기화하고 변수의 범위를 좁히는것이 주 목적으로 사용된다.
간결성을 지니는 이유는 var처럼 타입을 명시적으로 나타내지않고, 변수에 값을 나중에 할당하고 초기 값이 중요하지 않은경우 사용한다. 즉, 변수선언을 우선하고 값에의해 타입이 결정된 후 할당된다.
var 변수 선언과 다르게 := 변수의 타입은 표현에 의해서 결졍된다.
주의점은 var 키워드는 함수 내부, 외부에서 모두 사용가능하지만 := 연산자 선언은 함수 내부같은 지역변수를 선언할 때만 사용할 수있단것이다.
또한 여러개의 변수 선언과 같은 가독성을 높이기 위할때 사용하는것이 좋다.
짧은변수선언은 필수적으로 선언의 기능을 하진않는다.
만약 변수 중 하나가 관찰 가능한 범위 내에서 이미 선언되었다면 짧은변수 선언은 할당처럼 동작한다.
그리고 짧은 변수 선언은 재정의 시 오류 발생.
적어도 하나 이상의 새로운 선언이 필요하다
es, err := 1, 3	es, err := 1, 3
os, err := 1, 4	es, err := 1, 3 // error

var, short 다른점
1. var는 go언어에서 제공하는 문법적 키워드이다. / :=는 short declaration 'operator' 즉 연산자이다.
2. 함수 내,외 적으로 변수를 선언 ,초기화시 사용한다, / 오직 함수 내부에서만 선언이 가능하다.
3. 사용할 시 변수는 보통 패키지레벨 또는 글로벌 레벨 범위를 가진다. 또한 지역범위로도 사용이가능하다
/ 지역단위로의 범위만 가질 수 있고, 함수 내부에서만 선언된다.
4. 선언과 초기화를 따로할 수 있다. / 선언과 초기화가 동시에 이뤄진다.
5. 타입을 추가적으로 추가해줘야한다. / 타입을 입력할 필요가 없다.

2.3.2 포인터

변수란 값을 포함하는 저장소의 조각이다.
선언을 통해 생성된 변수는 이름에 의해 식별된다. ex) var x 등..
하지만 많은 변수는 표현에 의해 식별된다.  x[i]나 x.f등..
이러한 모든 표현은 변수의 값을 읽는다. 그들이 좌측 할당에서 나타날때를 제외하고.
이러한 경우는 새로운 값을 변수에 할당하는것이다.

포인터의 값은 변수의 주소이다.
그러므로 포인터란 값이 저장된 위치란 뜻이다.
포인터가 있다면 우리는 변수의 값을 즉시 읽거나 수정이 가능하다.

var x int라고 선언된 변수가 있다면 &x("address of x")라는 표현은 정수변수에 대한 포인터이다.
즉, *int 타입의 값이란 뜻이고 pointer to int 이므로 &x는 point to x 이 된다.
만약 x 가 p에의해 지목되면
p points to x이고 p는 x의 주소를 가진다 라고도 해석이 가능하다.
또한 배열같이 어떠한 타입을 묶어놓은 타입 또한 각 원소가 주소를 지닌다.
또한 포인터의 zero value는 nil이다.
또한 포인터끼리 비교할 시 같은 변수를 지목하면 같은 포인터이다.
이것은 함수에게 완벽히 안전하다 지역변수의 주소를 리턴할 때
예를들어 밑 코드에서  특정 함수호출 f에 의해서 v가 만들어지는데 v는 호출이 종료되어도 남아있다.
* 나중에 더..포인터는 flag 패키지의 키 포인트다.
커맨드 라인 인자에 특정 값을 프로그램을 통해 변수에 뿌린다.
실현을위해 

2.3.3 new function

변수 생성하는 방법임. built-in 함수인 new 함수 사용하는것
new(t)의 표현은 이름이 정해지지않은 타입 t 의 변수를 만든다. t의 zero value로 초기화된다.
그리고 주소를 리턴한다. 따라서 값의 타입은 *t이다.
"주로 구조체와 함께 사용할 때 유용하다"
func new(Type) *type
ex) p := new(int) p는 *int형 포인터변수이다.
new 함수를 이용하거나 var를 이용하거나 차이점이 없지만, new함수를 이용한 경우 명명하지 않아도 된다는 점이 있다. 왜 이게 편하냐면
예를들어 자료구조에서의 연결리스트를 만들 때 처음에 초기화를 할때 getnode()함수를 사용할 수 있는데 이 때 간편히 사용할 수 있다.

func getNode *node {
	return new(node)
}

또한 new 함수로 만들어진 포인터는 고유한 주소를 가진다.
p := new(int)
q := new(int)
fmt.Println(p == q) // false
룰의 하나의 예외가 있는데
유형이 정보를 전달하지 않고 따라서 크기가 0인 두 변수
struct {}나 [0]int 같은 경우 실행할 경우에 따르고 같은 주소를 가진다.

new함수는 상대적으로 드문드문 사용된다 왜냐하면 구조체 타입의 흔한 비작명 변수는 struct 리터럴 syntax가 더 유용하기때문

new 함수는 keyword가 아니므로 이름 재정의가능 
func delta(old, new int) int {return new - old}

2.3.4 변수의 생애주기
변수의 생애주기는 시간사이의 간격이다 프로그램이 실행되는 동안의
패키지레벨의 변수의 생애주기는 프로그램 전체의 실행시간동안이다.
대조적으로 지역변수는 동적인 생애주기를가진다.
새로운 인스턴스가 만들어지고 선언문이 실행될때, 변수는 살아있다 unreachable까지, 그시점 저장소는 재사용된다.
함수 매개변수와 결과 또한 지역변수와 같다. 함수가 호출될때부터 종료될때까지이다.

가비지콜렉터는 어케알고 수집하노?
기본 아이디어는 현재 활성화된 패키지레벨 변수 그리고 함수에서 활성화된 모든 지역변수는
잠재적으로 해당 변수에 대한 경로의 시작 또는 루트일 수 있다.
따라오는 포인터, 다른 종류의 참조는 궁극적으로 변수에게 이끈다.
만약 그러한 경로가 없다면 변수는 unreachable이 되고 이것은 더이상  남은 연산에 영향을 끼치지 못한다.

왜냐면 변수의 생애주기는 도달가능여부에 달려있기 때문이다.
지역변수는 생애주기가 연장된다 근처의 loop의 단독 반복에서
이것은 존재를 지속시키고 인접 함수가 닫힌후에도 지속된다.
컴파일러는 아마 고르려고 할것이다.. 할당한 지역변수 힙위의 또는 스택 하지만 아마도 놀랍게도
이 선택은 var 또는 new 에의해 선언될 때 결정되지않는다.
var global *int
func f() {			func g() {
	var x int			y := new(int)
	x = 1				*y = 1
	global = &x	}	
}
여기서 x는 힙에 할당되어야한다. 왜냐면 global변수에의해 f가 리턴된이후에도 관찰가능하기때문
우린 이것을 x가 excape from f 라고한다.
대조적으로 g는 리턴되면 변수 *y는 관찰되지못하고 재활용된다.
*y가 g에서 탈출하지 못했으므로 컴파일러는 *y를 스택에 할당하는것이 안전하다. new로 할당되었음에도 불구하고말이다.

어떠한 경우에도 escape의 개념은 코드작성 시 신경쓸 문제가 아니다.
그래도 항상 프로그램의 최적화 퍼포먼스를 위해서 기억해두는것이 좋다.
escape 작업시 추가적인 메모리 할당이 필요하기 때문이다.

쓰레기 수집은 좋은 프로그램을 작성하기 위해 엄청나게 도움이 된다.
하지만 당신이 메모리를 신경쓰지 않게 만든는것은 아니다.
당신이 명시적으로 메모리를 free해주지않아도 되지만 효율적인 프로그램을 위해 변수의 생애주기를 항상 염두에둬야한다.
예를들어 장수하는 물체, 특히 글로벌한 '변수' 안에 단명하는 물체에 대한 불필요한 포인터를 보관하는 것은 쓰레기 수집가가 단명된 객체를 수거하는것을 막을것이다.

2.4 할당
변수에 의해 잡힌 값은 할당문에 의해 갱신된다.
간단한 형태를 가진다 변수 = 표현
variable = expression

2.4.1 tuple 할당
할당의 다른형태, tuple 할당 허용한다. 다양한 변수를 한번에 할당하는것을
모든 오른쪽 표현은 평가된다 변수가 갱신되기 전에
이 형태를 가장 효율적으로 만드는것은 양 쪽에 변수ㅏ 할당되었을때이다. 예를들어 두 변수를 바꾸는 함수를 작성하려면?