go 특징
1. 정적타입
정적 타이핑은 프로그램 실행 전 옳은가를 체크함
이작업은 주로 언어의 컴파일러가 수행한다. 자바..

동적 타이핑은
프로그램 실행중에만 타입을 알 수 있음. 파이썬..
def erroneous():
    s = 'cat' - 1

print('hi!')
해당코드 오류 x 하지만 erroneous 호출 시 오류발생

2. 컴파일언어
컴파일 = 소스코드에서 목적코드로옮기는 작업
과정
1) 소스파일을 바이너리파일로 번역
2) 실행 후 cpu에서 ram으로 로드
3) 결과출력
c++, java, go 등..

cpu가 알아들을 수 있는 기계어로 번역하는것임. 바이너리파일이라고도불림

인터프리터는 소스코드 가 컴파일러아닌 인터프리터에게 직접 번역, 실행동시에함
실행파일 존재하지않음, os에서 ram에 로드되어 cpu에서 실행
소스코드 한줄한줄읽으며 실행
jsp, 파이썬, sql등..

컴파일장점 : 실행파일 존재하므로 인터프리터로 실행하는것보다 빠르게 동작
인터프리터 장점 : 컴파일x 별도의 컴파일시간 x
큰 소스코드에도 컴파일시간들지않아 바로실행가능

3. 가비지콜렉션
정의 : 사용되지 않는 메모리 공간을 free해주는것
즉, 범위 밖의 객체나 더이상 참조불가능한 객체의 메모리공간을 free하여 소비가능케만드는작업
이 작업은 프로그램 실행되는 동안 동시에 수행
바둑 가비지 수집기의 주요 관심사는 대기 시간이 짧다는 것인데, 이는 기본적으로 실시간 작업을 하기 위해 가동을 중단하는데도 금방 작업을 시작하기때문이다.
그럼 어떻게 이런 짧은 대기시간을가지는가?

한편, 프로그램이 하는 일은 항상 포인터를 사용하여 새로운 개체를 만들고 기존 개체를 조작하는 것이다.
이 프로세스는 이러한 개체를 가리키는 포인터가 없기 때문에 더 이상 액세스할 수 없는 개체를 생성하게 될 수 있다.
이 물건들은 쓰레기가 되고 쓰레기 수거업자가 그것들을 청소하고 그들의 기억 공간을 자유롭게 할 때까지 기다린다.
그 후 자유로워진 기억 공간은 다시 사용할 준비가 되어 있다.

- concurrent 마크앤스윕 알고리즘 사용
우선 각 Algorithm을 살펴보기에 앞서 어떤 Object를 Garbage로 볼 것이냐에 대한 이해가 글을 읽는 데 도움이 될 것이다. Garbage Collector는 객체를 Reachable과 Unreachable의 상태로 구분한다. 구분하는 방법은 Root set 과의 관계로 판단한다. Root Set으로부터 어떤 식으로든 Reference 관계가 있다면 Reachable Object라고 판단하고 Root Set으로부터 참조하는 Reference 관계가 없다면 Unreachable Object라고 판단한다. Root Set을 간단하게 설명하면 객체들 간에 참조 사슬의 시작점이라고 보면 된다.

- 초기 가비지콜렉션 알고리즘
Reference Counting Algorithm
Garbage의 Detection에 초점이 맞추어진 초기 Algorithm이다. 각 Object마다 Reference Count를 관리하여 Reference Count가 0이 되면 GC를 수행한다.
위 그림에서 a와 b는 각각 100, 99의 값을 갖는 Integer Object로 선언되어 있다. 각 Integer Object는 Referece Count가 1로 설정되어 있다. 이 상태에서 b = a로 변경하게 되면 a가 참조하고 있던 100의 값을 갖는 Integer Object는 참조가 없어지기 때문에 Reference Count가 0으로 감소하게 되고 GC가 수행된다.
이 방식은 Reference Count가 0이 될 때마다 GC가 발생하기 때문에 Pause Time이 분산되어 실시간 작업에도 거의 영향을 주지 않고 즉시 메모리에서 해제된다는 장점이 있으나 각 Object마다 Reference Count를 변경해 주어야 하고 참조를 많이 하고 있는 Object의 Reference Count가 0이 될 경우 연쇄적으로 GC가 발생할 수 있는 문제가 있고 Reference Count의 관리 비용도 크다. 또한 Linked List와 같은 순환 참조 구조에서 Memory Leak이 발생할 가능성도 크다.

